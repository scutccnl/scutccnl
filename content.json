{"meta":{"title":"ENJOYHOT","subtitle":null,"description":null,"author":"enjoyhot","url":"https://scutccnl.github.io"},"pages":[{"title":"Categories","date":"2016-07-08T09:48:21.085Z","updated":"2016-07-08T09:48:21.085Z","comments":true,"path":"categories/index.html","permalink":"https://scutccnl.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-08T09:47:36.433Z","updated":"2016-07-08T09:47:36.433Z","comments":true,"path":"tags/index.html","permalink":"https://scutccnl.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-07-08T09:48:26.477Z","updated":"2016-07-08T09:48:26.477Z","comments":true,"path":"about/index.html","permalink":"https://scutccnl.github.io/about/index.html","excerpt":"","text":"The blog theme you may fall in love with, coming to Hexo. Preview InstallationInstall1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus Icarus requires Hexo 3.0 and above. Enable Rename themes\\icarus\\_config.yml.example to themes\\icarus\\_config.yml; Copy themes\\icarus\\_config.yml.site.example to your hexo blog’s root directory and rename it to _config.yml; Copy themes\\icarus\\_source\\* into your hexo blog’s directory source; Then modify theme setting in _config.yml to icarus. Update12cd themes/icarusgit pull ConfigurationTheme configuration example1234567891011121314151617181920212223242526272829303132333435363738394041# Headermenu: Home: . Archives: archives Categories: categories # you need to add extra page to enable this, please see the config below. Tags: tags # you need to add extra page to enable this, please see the config below. About: about# Contentexcerpt_link: Read Morefancybox: true# Sidebarsidebar: rightwidgets:- recent_posts- category- tag- tagcloud- archivethumbnail: true# Contactscontacts: github: http://github.com/ppoffice/hexo-theme-icarus twitter: '#' facebook: '#' dribbble: '#' rss: atom.xml# Linkslinks: Hexo: http://hexo.io# Miscellaneousgoogle_analytics:favicon: favicon.pngtwitter:google_plus:fb_admins:fb_app_id: excerpt_link - Cooperate with &lt;!-- more --&gt; tag to show only part of the article in index pages. fancybox - Enable Fancybox. contacts - Your social network links, RSS link, etc. widgets - Widgets displaying in sidebar. thumbnail - Whether to show post thumbnails in the sidebar and archive pages. links - Links displayed in the link widget. google_analytics - Google Analytics ID. favicon - Favicon path. Site configuration example123456789101112131415# Sitetitle: Icarussubtitle:description: Hexo theme - Icarusauthor: PPOfficeauthor_title: 'Web Developer &amp; Designer'avatar: css/images/avatar.pnglocation: 'Harbin, China'language: entimezone:...# Disqusdisqus_shortname: author - Your name. author_title - Title to your occupation. avatar - Your avatar image link. location - Where you live in. disqus_shortname - Your Disqus shortname. Post Thumbnail &amp; BannerYou can add a thumbnail and a banner to each post by adding the following lines into your post source files’ front-matter:123456title: Demodate: 2015-01-01...# add thosethumbnail: http://example.com/thumbnail.jpgbanner: http://example.com/banner.jpg Custom Categories &amp; Tags PagesTo enable custom categories page and tags page, just copy the categories folder and tags folder under your theme’s _source foler into your site’s source folder. Then edit theme’s _config.yml and add the following lines:123456# Headermenu: ... Categories: categories # -&gt; add this line Tags: tags # -&gt; and add this line ... LanguagesEnglish and Simplified Chinese are the default languages of the theme. You can add translations in the languages folder and change the default language in blog’s _config.yml. 1language: zh-CN FeaturesProfile SidebarA nice place to show yourself. You can add your own information in your site’s _config.yml Post Banner &amp; ThumbnailThanks to atika, you can now add thumbnails and banners to every post to create better reading experience. Responsive LayoutIcarus knows on what screen size you are browsering the website, and reorganize the layout to fit your device. Custom Categories &amp; Tags PagesGet your categories and tags listed in single pages to make your blog more methodic. FancyboxIcarus uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 1![img caption](img url) SidebarIcarus provides 6 built-in widgets: recent_posts category archives tag tagcloud links All of them are enabled by default. You can edit them in widget setting. DevelopmentRequirements Grunt 0.4+ Hexo 3.0+ Grunt tasks default - Download Fancybox and Font Awesome. fontawesome - Only download Font Awesome. fancybox - Only download Fancybox. clean - Clean temporarily files and downloaded files."}],"posts":[{"title":"","slug":"hello-world","date":"2016-07-16T06:35:11.694Z","updated":"2016-07-16T06:35:11.694Z","comments":true,"path":"2016/07/16/hello-world/","link":"","permalink":"https://scutccnl.github.io/2016/07/16/hello-world/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Stacking","slug":"Stacking","date":"2016-07-08T09:04:30.000Z","updated":"2016-07-16T06:35:11.718Z","comments":true,"path":"2016/07/08/Stacking/","link":"","permalink":"https://scutccnl.github.io/2016/07/08/Stacking/","excerpt":"测试blog 相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示：","text":"测试blog 相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示： 整个过程很像 Cross Validation。对于一个model，首先将训练数据分为 5 份，接下来一共5个迭代，每次迭代时，将 4 份数据作为 Training Set 对每个 Base Model 进行训练，然后在剩下一份 Hold-out Set 上进行预测。那么一个model训练最终将合成一个完整对于原始训练样本的预测单列矩阵。 同时也要将其在测试数据上的预测保存下来。这样，每个 Base Model 在每次迭代时会对训练数据的其中 1 份做出预测，对测试数据的全部做出预测。 多个model迭代都完成以后我们就获得了一个 #训练数据行数 x #Base Model 数量 的矩阵，这个矩阵接下来就作为第二层的 Model 的训练数据。当第二层的 Model 训练完以后，将之前保存的 Base Model 对测试数据的预测（因为每个 Base Model 被训练了 5 次，对测试数据的全体做了 5 次预测，所以对这 5 次求一个平均值形成一列，多个model形成多列，从而得到一个形状与第二层训练数据相同的矩阵）拿出来让它进行预测，就得到最后的输出。 总的来说，Stacking 方法比任何单一模型的效果都要好，而且不仅成功应用在了监督式学习中，也成功应用在了非监督式(概率密度估计)学习中。甚至应用于估计bagging模型的错误率。据论文Feature-Weighted Linear Stacking(Sill, J. and Takacs, G. and Mackey L. and Lin D., 2009, arXiv:0911.0460)而言，Stacking比Bayesian Model Averaging表现要更好！此外在Kaggle上，很多比赛多是通过Stacking获取优秀的结果！","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://scutccnl.github.io/categories/Machine-Learning/"}],"tags":[{"name":"ML foundation","slug":"ML-foundation","permalink":"https://scutccnl.github.io/tags/ML-foundation/"}]},{"title":"ensemble-stacking","slug":"ensemble-stacking","date":"2016-05-08T09:04:30.000Z","updated":"2016-07-16T12:22:50.370Z","comments":true,"path":"2016/05/08/ensemble-stacking/","link":"","permalink":"https://scutccnl.github.io/2016/05/08/ensemble-stacking/","excerpt":"测试blog 相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示：","text":"测试blog 相比 Blending，Stacking 能更好地利用训练数据。以 5-Fold Stacking 为例，它的基本原理如图所示： 整个过程很像 Cross Validation。对于一个model，首先将训练数据分为 5 份，接下来一共5个迭代，每次迭代时，将 4 份数据作为 Training Set 对每个 Base Model 进行训练，然后在剩下一份 Hold-out Set 上进行预测。那么一个model训练最终将合成一个完整对于原始训练样本的预测单列矩阵。 同时也要将其在测试数据上的预测保存下来。这样，每个 Base Model 在每次迭代时会对训练数据的其中 1 份做出预测，对测试数据的全部做出预测。 多个model迭代都完成以后我们就获得了一个 #训练数据行数 x #Base Model 数量 的矩阵，这个矩阵接下来就作为第二层的 Model 的训练数据。当第二层的 Model 训练完以后，将之前保存的 Base Model 对测试数据的预测（因为每个 Base Model 被训练了 5 次，对测试数据的全体做了 5 次预测，所以对这 5 次求一个平均值形成一列，多个model形成多列，从而得到一个形状与第二层训练数据相同的矩阵）拿出来让它进行预测，就得到最后的输出。 总的来说，Stacking 方法比任何单一模型的效果都要好，而且不仅成功应用在了监督式学习中，也成功应用在了非监督式(概率密度估计)学习中。甚至应用于估计bagging模型的错误率。据论文Feature-Weighted Linear Stacking(Sill, J. and Takacs, G. and Mackey L. and Lin D., 2009, arXiv:0911.0460)而言，Stacking比Bayesian Model Averaging表现要更好！此外在Kaggle上，很多比赛多是通过Stacking获取优秀的结果！","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://scutccnl.github.io/categories/Machine-Learning/"}],"tags":[{"name":"ML foundation","slug":"ML-foundation","permalink":"https://scutccnl.github.io/tags/ML-foundation/"}]},{"title":"MS-document-online-preview","slug":"MS-document-online-preview","date":"2016-03-12T10:41:00.000Z","updated":"2016-07-16T12:22:50.370Z","comments":true,"path":"2016/03/12/MS-document-online-preview/","link":"","permalink":"https://scutccnl.github.io/2016/03/12/MS-document-online-preview/","excerpt":"doc,xls,ppt,pdf实现浏览器在线预览小记 一般有两种方式方式一：步骤 文档（PDF，Word，PPT等）–&gt;PDF–&gt;浏览器加载pdf插件在线浏览 转换pdf的软件： office:调用com接口，从而调用软件运行转换程序。 Openoffice： 目前隶属于Apache，从Openoffice.org沿袭而来。 LibreOffice： OpenOffice.org的分支,第一个正式版。 为3.3，对格式和字体的支持、对插件扩展与Openoffice有所侧重。","text":"doc,xls,ppt,pdf实现浏览器在线预览小记 一般有两种方式方式一：步骤 文档（PDF，Word，PPT等）–&gt;PDF–&gt;浏览器加载pdf插件在线浏览 转换pdf的软件： office:调用com接口，从而调用软件运行转换程序。 Openoffice： 目前隶属于Apache，从Openoffice.org沿袭而来。 LibreOffice： OpenOffice.org的分支,第一个正式版。 为3.3，对格式和字体的支持、对插件扩展与Openoffice有所侧重。 目前网络上各种转换方法，归根到底大多用到前两者，只是做了不同的代码封装。特别提一下，jacob.jar实现Word转换成PDF，一般用于Java，本质上也还是调用office。 doc2pdf软件优缺点（针对pythoner来说） office:自己安装com接口插件，调用软件运行转换程序,软件过于庞大，对于性能不太好的机器有时可能会崩溃。 Openoffice： 自带调用com接口API，python2.7.6内核，但是对于doc,docx格式兼容不好，转换格式不兼容的字体或者表格排版就呵呵了。 LibreOffice：自带调用com接口API，python3.3内核，暂时找不到2.7的，对doc,docx兼容较好。 目前自三种软件调用的脚步程序一抓一大把，都大致差不多，要注意的地方是，Dispatch, constants参数的慎重选择，如constants.wdXXX有时获取不靠谱，需要自己指定值。 浏览器pdf插件 下载自动安装有pdf插件的浏览器，目前chrome、搜狗、火狐都支持。 下载各种pdf阅读器进行关联，浏览器代理设置允许加载pdf阅读插件。 加载js插件，需要浏览器支持才行，不然还是会变成下载。http://www.cnblogs.com/58top/archive/2012/11/26/a-list-of-jquery-pdf-viewers-available-at-the-moment.html 试过：PDFObject，jQuery Media Plugin 方式二：步骤 文档（PDF，Word，PPT等）–&gt;PDF–&gt;转换为SWF–&gt; 使用FlexPaper在线浏览 软件介绍 Openoffice： word转pdf，同上分析。 SWFTools：将PDF转换为swf。 FlexPaper：一个开源轻量级的在浏览器上显示各种文档的组件，已经嵌入了flash播放器。 目前的优缺点 转换成功后crash的可能应该比直接用pdf低，保密性也较好，防复制防保存的功能可以进一步开发。 兼容性较好，无需担心浏览器插件问题。 处理流程多，对系统负担加大。 另外: 转换为html非常不靠谱。转换为html非常不靠谱。转换为html非常不靠谱。","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[]},{"title":"Git 协作纪要","slug":"git-notes","date":"2015-12-12T10:41:00.000Z","updated":"2016-07-16T12:22:50.370Z","comments":true,"path":"2015/12/12/git-notes/","link":"","permalink":"https://scutccnl.github.io/2015/12/12/git-notes/","excerpt":"一、常用开发模式先看一张图 注意：1、少用pull或不用pull；2、本地的多个分支，如果不是用命令行的话，对文件修改是对所有分支内容修改。 git clone -&gt; 修改 -&gt;","text":"一、常用开发模式先看一张图 注意：1、少用pull或不用pull；2、本地的多个分支，如果不是用命令行的话，对文件修改是对所有分支内容修改。 git clone -&gt; 修改 -&gt; 以下分情况讨论： 1、当你采用本地commit再远程push的连贯方式 (将远程master获取到本地仓库假设为tmp，为后期查看log或merge等)git fetch origin master -&gt;(查看本地master和刚才fetch的origin/master直接2条差异，-p查看详细)git log master origin/master -n 示例： -&gt;(合并origin/master到本地的master，这一步往往比较揪心，可能有冲突，解决后需：git add xx git commit xx) 当别人比你先提交时，会出现这个错误： 解决：git stash git pull git stash pop (一个个文件查看改动，无问题则add，然后commit，然后git diff –stat看看还有多少)git diff -w app/auth/views.py(add 一个少一个)git diff --stat (记得commit)git merge origin/master-&gt;(提交到远程origin/master)git push origin/master2、当你采用本地commit，过一段较长时间再远程push的方式 -&gt;git fetch origin master-&gt;git merge origin/master这时那些不一致的就会发生冲突 修改文件内容的冲突后，这时你通过git add和git commit可解决 -&gt;git push origin/master 3、tips 当查看别人甚至做了一些调试，要撤销pull以来（或者说commit之后）的操作，则用git checkoutgit checkout -- filename用暂存区中filename文件来覆盖工作区中的filename文件(慎用【git checkout . 】表示所有)。 二、改进工作流习惯了merge之后，对git的工作流维护也是相当重要，主要是方便差错，对于各个commit的整理也是有益的。1、git rebase重新定义(re)起点(base),整合工作流。 merge git checkout mywork git merge origin 会生成如下的树（借用网上的图）： 这样C5、C6都属于工作流的一部分，当你回退到C5时就没应用到C4的修改，需要再进行操作。 如果用rebase： git checkout mywork git rebase origin 把orgin的最新commit C4 作为当前分支mywork的基础，则生成的树图示如下： 配合远程 git pull --rebase origin master –rebase选项告诉Git，在同步了中央仓库的修改之后，将Mary所有的提交移到master分支的顶端。 假如冲突 git add . git rebase --continue 注：rebase的操作相对于merge操作，因为发生了时间跳跃，当发生冲突时会比较混乱（虽然 我还没遇到）。 三、分支1、新建本地分支git branch gujw2、查看本地分支git branch3、切换本地分支git checkout gujw示例： 4、查看远程分支git branch -a示例： ###三、仓库移动 当远程仓库域名什么的发生变化，应该是比较常见的情况。 1、查看当前本地仓库链接到的远程仓库git remote -v2、按照格式更改url即可git remote set-url XXXXX ###四、撤销操作 如果你推送到remote的commit没有被其他人pull过，那么你可以使用git reset --hard &lt;commit-hash&gt; //可以用客户端Amend代替 git push -f origin master …","categories":[{"name":"git","slug":"git","permalink":"https://scutccnl.github.io/categories/git/"}],"tags":[{"name":"协作","slug":"协作","permalink":"https://scutccnl.github.io/tags/协作/"}]},{"title":"通过欢迎度对网页排名","slug":"通过欢迎度对网页排名","date":"2015-05-03T07:30:50.000Z","updated":"2016-07-16T06:35:11.722Z","comments":true,"path":"2015/05/03/通过欢迎度对网页排名/","link":"","permalink":"https://scutccnl.github.io/2015/05/03/通过欢迎度对网页排名/","excerpt":"声明：由于此次第一次使用动态加载的表达式，hexo对LaTex支持可能不太好，因此这里有些公式显示奇奇怪怪，排版比较好一点的参考csdn:博客链接,下次就直接上图片算了。免得这边不兼容。 一、欢迎度历史1998年 Jon Kleinberg致力于HITS的万维网搜索引擎项目，其中的算法使用了万维网的超链接结构来改进搜索引擎所得的结果。 同时，在离他很近的斯坦福大学里，两名博士生正在从事一项名为PageRank的类似项目，分别是Sergey Brin和Larry Page。","text":"声明：由于此次第一次使用动态加载的表达式，hexo对LaTex支持可能不太好，因此这里有些公式显示奇奇怪怪，排版比较好一点的参考csdn:博客链接,下次就直接上图片算了。免得这边不兼容。 一、欢迎度历史1998年 Jon Kleinberg致力于HITS的万维网搜索引擎项目，其中的算法使用了万维网的超链接结构来改进搜索引擎所得的结果。 同时，在离他很近的斯坦福大学里，两名博士生正在从事一项名为PageRank的类似项目，分别是Sergey Brin和Larry Page。这两个模型之间的联系令人吃惊。然而，Jon并未试图将HITS发展成为一家公司，不过后来企业家们却试着去做了，并因此而赋予了HITS那迟到的商业成功。搜索引擎Teoma的技术基础就是HITS算法的一个扩展。 在介绍之前，我们先将万维网的超链接结构形成一个巨大的有向图，有向链接分为岀链和入链。 网络有向图 1.1 PageRankPagerank的论点是，如果一个网页被其他重要的页面所指向，那它就是重要的。值得注意的是，推荐者的地位对推荐的作用是有一定联系的，也与推荐者推荐的总数有所关联。 1.2 HITSHITS定义了枢纽（hub）和权威（authority），这是网页的属性，当然一个网页可以两者都是。论点是，如果一个页面指向好的权威网页，那它就是一个好的枢纽网页（从而配上一个高的枢纽评分）；而如果一个网页被好的枢纽网页所指向，那它就是一个好的权威网页。 1.3 查询相关性如果每个页面的欢迎度评分是离线确定的，并且对于无论哪个查询而言（直至下次更新前）均保持恒定，则排名称为查询无关的PageRank是查询无关的，HITS的原始版本是查询相关的。它们二者都可以修改为相反的那个类型。 二、谷歌的PageRank数学2.1 求和公式某个页面的Pi的PageRank记为r(Pi)，它是所有指向Pi的页面的PageRank之和。$$ r(Pi) =\\sum{Pj \\in B{P_i}} \\dfrac{r(P_j)}{|Pj|} $$Bpi为指向Pi的页面集合，|Pj|是由Pj发出的岀链数量。通过迭代的方式，解决通过未知页面的PageRank值得出另外未知页面的PageRank值。为了定义这一迭代过程，我们引入更多的记号，令$r{k+1}(Pi)$表示为页面Pi在第k+1次循环时的PageRank，则$$ r{k+1}(Pi) =\\sum{Pj \\in B{P_i}} \\dfrac{r_k(P_j)}{|Pj|}(1) $$将所有页面Pi均具有$r{0}(P_i) =1/n$开始，并一直重复下去，直至收敛到稳定值。 2.2求和方程的矩阵表示打个比方，以下面这个图为例我们引入一个n x n阶的矩阵H和一个1 x n阶的行向量$\\pi^T$。矩阵H是一个行归一化超链接矩阵，则上图相应H为：$$ H= \\begin{matrix} \\pmatrix{ 0 &amp; 1/2 &amp; 1/2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 1/3 &amp; 1/3 &amp; 0 &amp; 0 &amp; 1/3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1/2 &amp; 1/2 \\ 0 &amp; 0 &amp; 0 &amp; 1/2 &amp; 0 &amp; 1/2 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\} \\end{matrix} $$向引入行向量$\\pi^{(k)T}$，它表示在第k次循环时的PageRank向量。则(1)式可表示为：$$\\pi^{(k+1)T}=\\pi^{(k)T}H (2)$$从这个H矩阵可以看出一些端倪，书中总结出4个，我觉得关键在于在计算中通过矩阵计算降低复杂度，这在现实中是个稀疏矩阵，复杂度对于理论来说由平方降为1次。 2.3迭代过程问题是否会收敛？收敛到唯一向量吗？是否与初始向量有关？收敛时间？ 以下分析为两位Google创始人解决的迭代问题。 布林和佩奇最初利用$\\pi^{(0)T}=1/ne^T$来开始迭代过程，但这可能导致排名下沉(rank sink)，譬如出现多个0，可比性降低，排名下沉很大程度上与悬挂节点（岀链为0）的出现有关。 为了解决这个问题，他们使用了随机上网者的概念，对H矩阵进行调整，随机上网者特点为： 随机岀链，包括悬挂节点 随机上网者在某个特定页面上所停留的时间比例便是该页面相对重要性的一个度量 于是，我们将H矩阵变为随机矩阵S：$$ S= \\begin{matrix} \\pmatrix{ 0 &amp; 1/2 &amp; 1/2 &amp; 0 &amp; 0 &amp; 0 \\ 1/6 &amp; 1/6 &amp; 1/6 &amp; 1/6 &amp; 1/6 &amp; 1/6 \\ 1/3 &amp; 1/3 &amp; 0 &amp; 0 &amp; 1/3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1/2 &amp; 1/2 \\ 0 &amp; 0 &amp; 0 &amp; 1/2 &amp; 0 &amp; 1/2 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\} \\end{matrix} $$可以证明，S是由H的一个秩一修正所给出的，即$S=H + a(1/n e^T)$，其中，若页面i为悬挂结点则ai=1，否则为0。二值向量a为悬挂结点向量，为列向量。 然而，仅靠这一点还不够，未能达成存在唯一的正向量$\\pi^T$ ,且方程能很快地收敛到$\\pi^T$。要做到这一点，布林和佩奇做了另外一个调整，所谓的素性调整。有了这个调整，所得的矩阵就是随机的并且是素的。一个素矩阵是不可约的并且非周期的，因此，链的稳态向量存在且唯一。 转换为素矩阵是基于这样一个论述的。上网者有时会在浏览器URL地址栏输入一个新的目的地，为了对这个行为进行数学建模，布林和佩奇创造了一个新的矩阵G如下： $$ G=\\alpha S + (1-\\alpha)1/n ee^T$$ 式中，a是一个0到1的标量(在之后的章节会反复提到a在谷歌中取0.85)，表示随机上网者根据万维网的超链接结构进行浏览的时间百分比。G成为谷歌矩阵，$E=1/n ee^T$可称为跳转矩阵，是均匀分布的，即在进行跳转时是公平跳转。 在书中，分为6点简单概括G带来的后果： G是随机的。 G是不可约的。 G是非周期的，Gii&gt;0导致。 G是素的。 G是完全稠密的。从计算的角度，这是很糟糕的。但G可以写为非常稀疏的超链接矩阵H的秩一修正。 \\begin{align}G &amp;=\\alpha S + (1-\\alpha)1/n ee^T \\&amp; =\\alpha (H + a(1/n e^T)) + (1-\\alpha)1/n ee^T \\&amp; =\\alpha H+[\\alpha(a)+(1-\\alpha)e]1/ne^T\\end{align} 因此，谷歌修正后的PageRank法为$$\\pi^{（k+1）T}=\\pi^{（k）T}G$$ 2.4 PageRank向量的计算将求解$\\pi^T$转换为如下特征向量问题$$\\pi^T=\\pi^TG \\ \\pi^Te=1$$将求解$\\pi^T$转换为求解如下的性齐次系统：$$\\pi^T(E-G)=0^T \\ \\pi^Te=1$$第一个系统为找到对应于主特征值$\\lambda_1=1$的G的归一化主左特征向量。在第二个系统中，目标则是找到E-G的归一化左零向量。两个系统均服从归一化方程$\\pi^Te=1$，该方程确保$\\pi^T$是一个概率向量。 2.4.1 幂法计算PageRank矩阵G的特点使得幂法成为了显而易见的最佳选择。幂法是求取矩阵主特征值和特征向量的最古老同时也是最简单的迭代方法之一。缺点的计算速度缓慢。\\begin{align} \\pi^{（k+1）T} &amp; =\\pi^{（k）T}G \\ &amp; =\\alpha S + (1-\\alpha)1/n \\pi^{（k）T} ee^T \\ &amp; =\\alpha (H + a(1/n e^T)) + (1-\\alpha)1/n ee^T \\ &amp; =\\alpha \\pi^{（k）T} H+[\\alpha \\pi^{（k）T} a+1-\\alpha]e^T/n \\end{align}式中，向量-矩阵乘法$\\alpha \\pi^{（k）T} H$执行于H这个极端稀疏的矩阵之上，而S和G从来就没有被实际生成或存储过，每个向量-矩阵乘法的复杂度为O(n)，因为H的每一行有差不多10个非零元素，这就是使用幂法的主要原因。这里还有几个优点： 幂法中矩阵系数仅通过向量-矩阵乘法运算的程序来进行访问，而没有实际对矩阵加以操作。 幂法存储方面，除了稀疏矩阵H和悬挂结点向量a之外，就只需要保存\\alpha \\pi^{（k）T}$了，这个向量是完全稠密的。 迭代次数仅需50~100次。 为什么仅需50次呢，解释一下，在马尔科夫链理论中给出了答案，一般而言，应用于某个矩阵的幂法的渐进收敛速率依赖于绝对值最大的两个特征值$\\lambda_1$和$\\lambda2$的比值。确切来说，渐进收敛速率就是$ |\\lambda/\\lambda_1|^k \\to 0 $的速率。 对于G这样的随机矩阵，$\\lambda_1=1$，由于G也是素的，因此$|\\lambda_2|&lt;1$。 通过一些理论的支撑，有以下关系：$$\\lambda_k=\\alpha \\mu_k$$其中$\\mu_k&lt;=1$ 在万维网结构中，$\\mu_k$约等于1，因此，$|\\mu_2(G)| \\approx \\alpha$。 因此，渐进收敛速率在50次的情况为：$$\\alpha ^{50}=0.85^{50} \\approx 0.000296$$即在第50次迭代时，可以期望近似PageRank向量的精度大约为小数点后2~3位。这个精度已经足够了，当然要真正区分需要小数点后10位精度，但是当PageRank评分和内容评分结合起来之后，高精度就变得不那么重要了。","categories":[{"name":"Search Engine","slug":"Search-Engine","permalink":"https://scutccnl.github.io/categories/Search-Engine/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"https://scutccnl.github.io/tags/PageRank/"}]},{"title":"网络搜索引擎简介","slug":"网络搜索引擎简介","date":"2015-04-21T05:23:50.000Z","updated":"2016-07-16T06:35:11.726Z","comments":true,"path":"2015/04/21/网络搜索引擎简介/","link":"","permalink":"https://scutccnl.github.io/2015/04/21/网络搜索引擎简介/","excerpt":"一、传统信息检索回顾传统信息检索文档集的搜索有三种基本的计算机辅助技术：布尔模型、向量空间模型和概率模型。这些模型发展与20世纪60年代，直到2000年6月，便存在3500种不同的搜索引擎技术，并且大多数搜索引擎仍然依赖于以上三种基本模型的一种或数种。下图摘自《搜索引擎-原理技术与系统》，显示了搜索的主干流程。","text":"一、传统信息检索回顾传统信息检索文档集的搜索有三种基本的计算机辅助技术：布尔模型、向量空间模型和概率模型。这些模型发展与20世纪60年代，直到2000年6月，便存在3500种不同的搜索引擎技术，并且大多数搜索引擎仍然依赖于以上三种基本模型的一种或数种。下图摘自《搜索引擎-原理技术与系统》，显示了搜索的主干流程。 ##1.1 布尔搜索引擎信息检索中最早而且最简单的检索方法之一。布尔逻辑检索也称作布尔逻辑搜索，严格意义上的布尔检索法是指利用布尔逻辑运算符连接各个检索词，然后由计算机进行相应逻辑运算，以找出所需信息的方法。它使用面最广、使用频率最高。布尔逻辑运算符的作用是把检索词连接起来，构成一个逻辑检索式。 ##1.2向量空间模型搜索引擎向量空间模型将文本数据变换为数值向量和矩阵，然后使用矩阵分析方法来发现文档集中的关键特征和联系。某些高级向量空间模型，如LSI（Latent Semantic Indexing,隐性语义索引）等能访问文档集中隐含的语义结构，如搜索car,能返回automobile相关文档。该模型还有另外两个优点是相关性评分和相关性反馈。缺点是计算开销大，查询时必须计算每个文档和查询之间的距离度量，因而也伴随着另一个缺点——向量空间模型无法很好地扩展。 1.3概率模型搜索引擎用户给定一个查询请求，概率检索模型根据文档与用户请求的相关性排序文档，给出结果，举个简单的例子，对于信息检索的文档，最可能跟在information后面的词是retrieval，但独立性假设却认为任何词都会以等概率出现在information后面。重点在于相关性的定义与衡量。概率模型的构建和编程有可能十分困难，它们的复杂度上升得很快。 ##1.4元搜索引擎传统搜索引擎其实还有第四种模型，即元搜素引擎。它将以上三种经典模型合为一体。 ##1.5搜索引擎的比较两种最为常用的评价不同搜索方法的评价指标是查准率和查全率。查准率是指检索所得相关文献的数量占总的检索所得文献数量的比例；查全率是指检索所得相关文献数量占总的相关文献数量的比例。查准率和查全率越高，搜索引擎就越好。 #二、网络搜索引擎 爬虫模块：蜘蛛 页面仓库：蜘蛛满载页面而回，它们暂时以完整页面的形式存放在页面仓库中，而在被送到索引建立模块之前，新的页面将一直留在仓库中。 索引建立模块：取出每个新的未压缩页面，并从中仅抽取出最为重要的描述，以生成该页面在不同索引中的一个压缩描述。 索引：分为内容索引和特殊用途索引（如图像索引和PDF索引） 查询模块：将用户的自然语言查询转化为搜索系统可以理解的语言，然后查询不同的索引以便回答查询。 排名模块：接收相关页面集，并根据某个判断依据对其进行排名。区分能力的排名是结合两个分数得到的，它们分别是内容评分和欢迎度评分，共同确定了相关页面的总评分，并按照总评分的顺序将页面集呈现给用户。 #三、网络爬行、索引建立和查询处理 ##3.1 网络爬行特点：1.爬行是一个永不停歇的过程2.蜘蛛访问网页时，需做到有礼貌的访问，即对网站的影响降到最小，不然可能会被“惩处”3.多个蜘蛛协调合作，制定最佳爬行策略，节省时间和精力，尽可能提高效率 ##3.2 内容索引程序将分析页面内容并抽取有价值的信息，从而仅将页面中最为关键的核心部分传给适当的索引。有价值的信息存在于标题、描述和锚文本中，此外还有粗体显示的项、大字体显示的项和超链接等。建立索引后形成倒排文件，形如：什么是倒排文件？如下例子（其中001~004对应为文档编号）：001 xxx142 张三 男 18 元培002 xxx205 李四 女 17 哲学003 xxx187 王五 男 19 生物004 xxx325 赵六 女 18 元培而我们利用倒排文件来实现上述非关键码的查询，就能大大提高速度。对于前面的情况设计倒排表如下：男 001，003女 002，004 1617 00218 001，00419 00320 元培 001，004生物 003哲学 002 ##3.3查询处理查询处理的结果，将以文档的相关评分返回，举个例子。在文档集中查询项a和项b的组合词ab，返回的结果有：项a : 3[1,1,27],94[1,0,7],673[0,0,3]项b : 3[1,1,10,94[0,0,5] ,673[1,1,14]如94[1,0,7]中，1表示的是项a在页面94的标题中出现了，0表示项a在页面的描述标签未出现，7表示项a在页面94中出现了7次。因此，内容得分可以这样来计算：内容得分（页面3）= （1+1+27）x (1+1+10)=348内容得分(页面94)=（1+0+7）x (0+0+5)=40内容得分(页面673)=（0+0+3）x (1+1+14)=48 有多种方案可以利用许多其它的因子来构成内容评分，这里只是随便举了一种。 内容评分和欢迎度评分决定了一个网页的最终评分，由于本书的重点在与欢迎度评分，因为在之后的介绍中将不多涉及内容评分。","categories":[{"name":"Search Engine","slug":"Search-Engine","permalink":"https://scutccnl.github.io/categories/Search-Engine/"}],"tags":[{"name":"PageRank","slug":"PageRank","permalink":"https://scutccnl.github.io/tags/PageRank/"}]},{"title":"export CSDN blog to Markdown","slug":"CSDN2Markdown","date":"2015-03-29T08:40:00.000Z","updated":"2016-07-16T06:35:11.690Z","comments":true,"path":"2015/03/29/CSDN2Markdown/","link":"","permalink":"https://scutccnl.github.io/2015/03/29/CSDN2Markdown/","excerpt":"#一、综述 最开始的博客用的是oschina, 自我感觉小清新，支持比较多风格的编辑器，容易编辑程度比csdn的要好。后来因为csdn人气的关系，又转到csdn，不过csdn编辑确实比较虐心，再后来就在服务器上搭一个WordPress的博客，不过用起来不是很爽。几个月前支持Markdown编辑，这无疑给用github pages的用户一个福音，因为可以直接上传到自己的github博客上。","text":"#一、综述 最开始的博客用的是oschina, 自我感觉小清新，支持比较多风格的编辑器，容易编辑程度比csdn的要好。后来因为csdn人气的关系，又转到csdn，不过csdn编辑确实比较虐心，再后来就在服务器上搭一个WordPress的博客，不过用起来不是很爽。几个月前支持Markdown编辑，这无疑给用github pages的用户一个福音，因为可以直接上传到自己的github博客上。用github pages生成静态的页面，目前比较流行有Jekyll,Octopress,Hexo等，其他的我没怎么调查，jekyll是github推荐的，上面有他们给的官方框架、主题，支持网页书写Markdown文章。后两者需要编译后再上传，github上呈现出来的是html文件。总体而言，后两者的界面更好，用起来更加舒适。我用的是Hexo，命令简洁，不过要注意备份整个工程，不然后果不堪设想。 #二、迁移CSDN原文档到github Pages ###1、前文虽然目前CSDN支持markdown，但以前的文章都是用xeditor编辑器写的，不能导出，所以调研了方法。总体而言有两种方法，但好像没多少人采用，因为格式可能不好。1.爬取页面，导出html，然后在放在hexo中，目录为/source/_post/，直接放html文件，然后设置layout：false，那么hexo会忽略对html的编译，在浏览时直接超链接到html文件2.将html文件再用程序转换为markdown3.直接用代码爬取页面然后生成markdown文件 第1种方法可能会遇到html文件中格式不支持的情况，没得到解决；第2种方法发现在线转换效果也不好，就寻求代码解决，github上有一段程序，作者说可行，不过我环境没搭成功，不懂php，更何况要装curl（这个之前做android时NDK开发时也很难配置），后来用第3种方法就直接写python爬虫程序，参考github的一段程序，不过程序有些问题，也有些不符合如今CSDN的布局，所以我大改了一下，转为markdown的那一部分程序脉络是差不多的，这个也是最关键的部分，直接影响到markdown的显示，不过我也做得不太好。 ###2、程序所需安装库：BeautifulSoup根据版本不同可能要改动相应的代码，一般不用改。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253#! /usr/bin/env python#coding=utf-8import urllib2from bs4 import BeautifulSoupimport loggingimport reimport threadingimport tracebackimport time import datetimeimport sysreload(sys)sys.setdefaultencoding('gb18030')# global variableblog = \"http://blog.csdn.net\"url = \"http://blog.csdn.net/gugugujiawei?viewmode=contents\"outputDir = 'F:\\\\linux\\\\Share\\\\github\\\\article\\\\'gRetryCount = 4def decodeHtmlSpecialCharacter(htmlStr): specChars = &#123;\"&amp;ensp;\" : \"\", \\ \"&amp;emsp;\" : \"\", \\ \"&amp;nbsp;\" : \"\", \\ \"&amp;lt;\" : \"&lt;\", \\ \"&amp;gt\" : \"&gt;\", \\ \"&amp;amp;\" : \"&amp;\", \\ \"&amp;quot;\" : \"\\\"\", \\ \"&amp;copy;\" : \"®\", \\ \"&amp;times;\" : \"×\", \\ \"&amp;divide;\" : \"÷\", \\ &#125; for key in specChars.keys(): htmlStr = htmlStr.replace(key, specChars[key]) return htmlStrdef repalceInvalidCharInFilename(filename): specChars = &#123;\"\\\\\" : \"\", \\ \"/\" : \"\", \\ \":\" : \"\", \\ \"*\" : \"\", \\ \"?\" : \"\", \\ \"\\\"\" : \"\", \\ \"&lt;\" : \"小于\", \\ \"&gt;\" : \"大于\", \\ \"|\" : \" and \", \\ \"&amp;\" :\" or \", \\ &#125; for key in specChars.keys(): filename = filename.replace(key, specChars[key]) return filenamedef getPageUrlList(url): global blog #获取所有的页面的 url user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' header = &#123; 'User-Agent' : user_agent &#125; request = urllib2.Request(url, None, header) response = urllib2.urlopen(request) data = response.read() #print data soup = BeautifulSoup(data) pageListDocs = soup.find_all(id=\"article_list\") # artclie----&#123;url:title&#125; articleUrlTitle = &#123;&#125; #print len(pageListDocs) for pageList in pageListDocs: h1List = pageList.find_all('h1') for articleList in h1List: hrefDocs = articleList.find_all(\"a\") if len(hrefDocs) &gt; 0: articleHrefDoc = hrefDocs[0] #print \"hello\",articleHrefDoc articleUrl = blog + articleHrefDoc[\"href\"] articleTitle = articleHrefDoc.text articleUrlTitle[articleUrl] = articleTitle print 'the count of articles is',len(articleUrlTitle) ''' for s in articleUrlTitle: print s,'--',articleUrlTitle[s] ''' return articleUrlTitledef download(url, title): # 下载文章，并保存为 markdown 格式 logging.info(\" &gt;&gt; download: \" + url) print 'downloading the article',title data = None title = '\"' + title + '\"' categories = \"\" content = \"\" #postDate = datetime.datetime.now() global gRetryCount count = 0 while True: if count &gt;= gRetryCount: break count = count + 1 try: time.sleep(2.0) #访问太快会不响应 user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' header = &#123; 'User-Agent' : user_agent &#125; request = urllib2.Request(url, None, header) response = urllib2.urlopen(request) data = response.read() break except Exception,e: exstr = traceback.format_exc() logging.info(\" &gt;&gt; failed to download \" + url + \", retry: \" + str(count) + \", error:\" + exstr) pass if data == None: logging.info(\" &gt;&gt; failed to download \" + url) return #print data soup = BeautifulSoup(data) #date=link_postdate manageDocs = soup.find_all(\"div\", \"article_manage\") for managerDoc in manageDocs: categoryDoc = managerDoc.find_all(\"span\", \"link_categories\") if len(categoryDoc) &gt; 0: categories = categoryDoc[0].a.get_text().encode('UTF-8').strip() categories = categories.decode('utf-8').encode('gb2312') postDateDoc = managerDoc.find_all(\"span\", \"link_postdate\") if len(postDateDoc) &gt; 0: postDateStr = postDateDoc[0].string.encode('UTF-8').strip() postDate = datetime.datetime.strptime(postDateStr, '%Y-%m-%d %H:%M') print 'date',postDate contentDocs = soup.find_all(id=\"article_content\") for contentDoc in contentDocs: htmlContent = contentDoc.prettify().encode('UTF-8') #print htmlContent #file = open('F:\\\\linux\\\\Share\\\\github\\\\out2.txt','a+') #file.write(htmlContent) content = htmlContent2String(htmlContent) exportToMarkdown(outputDir, postDate, categories, title, content)# htmlContent2String 是整个程序的关键，用于将html转换为markdown格式def htmlContent2String(contentStr): # 因为格式中可能会有点乱，换行符乱入，所以用[\\s\\S]匹配任何字符，包括换行符，注意其中的？是为了去除贪婪匹配 # &lt;img src=\"http://img.blog.csdn.net/20150118194525562\" align=\"middle\" width=\"400 height=\"300\" alt=\"\"&gt; # 图片链接 patternImg = re.compile(r'(&lt;img[\\s\\S]+?src=\")([\\s\\S]+?)(\"[\\s\\S]+?&gt;)') # &lt;a target=\"_blank\" href=\"http://blog.csdn.net/gugugujiawei/article/details/42558411\"&gt;博文&lt;/a&gt; # 文字链接 patternHref = re.compile(r'(&lt;a[\\s\\S]+?href=\")([\\s\\S]*?)(\"[\\s\\S]*?&gt;)([\\s\\S]+?)(&lt;/a&gt;)') # 去除html各种标签，这里的？则是指匹配0次或1次 patternRemoveHtml = re.compile(r'&lt;/?[^&gt;]+&gt;') resultContent = patternImg.sub(r'![image_mark](\\2)', contentStr) resultContent = patternHref.sub(r'[\\4](\\2)', resultContent) resultContent = re.sub(patternRemoveHtml, r'', resultContent) resultContent = decodeHtmlSpecialCharacter(resultContent) #file = open('F:\\\\linux\\\\Share\\\\github\\\\out3.txt','a+') #file.write(resultContent) return resultContentdef exportToMarkdown(exportDir, postdate, categories, title, content): titleDate = postdate.strftime('%Y-%m') contentDate = postdate.strftime('%Y-%m-%d %H:%M:%S %z') filename = title filename = repalceInvalidCharInFilename(filename) filepath = exportDir + filename + '.txt' #newFile = open(unicode(filepath, \"utf8\"), 'w') newFile = open(filepath,'a+') # 根据自己需要选择去留注释,这里categores和tag用了一样的 # newFile.write('---' + '\\n') # newFile.write('layout: post' + '\\n') newFile.write('title: ' + title + '\\n') newFile.write('date: ' + contentDate + '\\n') # newFile.write('comments: true' + '\\n') newFile.write('categories: [' + categories + ']' + '\\n') newFile.write('tags: [' + categories + ']' + '\\n') #newFile.write('description:' + title + '\\n') # newFile.write('keywords: ' + categories + '\\n') newFile.write('---' + '\\n\\n') content = content.decode('utf-8').encode('gb18030') #print content newFile.write(content) newFile.write('\\n') newFile.close()if __name__ == \"__main__\": global url articleUrlTitle = getPageUrlList(url) ''' for s in articleUrlTitle: print s,'--',articleUrlTitle[s] ''' #multithread download threads = [] for url in articleUrlTitle: patternTitle = re.compile('\\r\\n *(.+) *\\r\\n') title = patternTitle.sub(r'\\1',articleUrlTitle[url]) # print 'title',title t = threading.Thread(target = download,args = (url,title)) t.start() threads.append(t) for i in threads: i.join() print \"success\" 注意一下，我是直接在windows下运行生成的txt文件，所以文件时dos文件，当在linux下编辑的话会出现各种因格式问题导致的奇怪的问题，这需要自己改一下编码。","categories":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/categories/life/"}],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"https://scutccnl.github.io/tags/CSDN/"},{"name":"markdown","slug":"markdown","permalink":"https://scutccnl.github.io/tags/markdown/"}]},{"title":"photos","slug":"myphoto","date":"2015-03-26T15:45:21.000Z","updated":"2016-07-16T06:35:11.706Z","comments":true,"path":"2015/03/26/myphoto/","link":"","permalink":"https://scutccnl.github.io/2015/03/26/myphoto/","excerpt":"","text":"say something show","categories":[{"name":"photo","slug":"photo","permalink":"https://scutccnl.github.io/categories/photo/"}],"tags":[{"name":"photo","slug":"photo","permalink":"https://scutccnl.github.io/tags/photo/"}]},{"title":"HPC集群平台搭建概念","slug":"HPC-cluster","date":"2015-03-24T12:23:50.000Z","updated":"2016-07-16T06:35:11.694Z","comments":true,"path":"2015/03/24/HPC-cluster/","link":"","permalink":"https://scutccnl.github.io/2015/03/24/HPC-cluster/","excerpt":"在本文之前，我建议先看完这篇文章：Linux高性能计算集群 – Beowulf集群 #一、搭建集群中可能会遇到的问题 1.集群设计/布局的一大难点就是网络，各家有各家的策略，一般围绕Beowulf变型。2.软件的部署缺乏实操调试，也不能断定这样部署是否成功以及是否优越。3.操作系统的选型以及安装系统、所需软件（包括集群管理工具、驱动软件、能耗监控软件等）的整个流程的手动/自动化部署。","text":"在本文之前，我建议先看完这篇文章：Linux高性能计算集群 – Beowulf集群 #一、搭建集群中可能会遇到的问题 1.集群设计/布局的一大难点就是网络，各家有各家的策略，一般围绕Beowulf变型。2.软件的部署缺乏实操调试，也不能断定这样部署是否成功以及是否优越。3.操作系统的选型以及安装系统、所需软件（包括集群管理工具、驱动软件、能耗监控软件等）的整个流程的手动/自动化部署。4.每个提供硬件的对应公司几乎都推出他们自己的集群管理软件，浪潮好像没有，在HPC方面浪潮好像没有相应的开发社区，DELL和IBM这些大公司都有。5.能耗的衡量，具体的优化方向和策略。 #二、HPC概览 ##①总体构成 Outside Network: 外部网络 Master Node: 主节点 Compute Nodes: 计算节点 Storage: 存储器 Computational Network: 计算网络 Management Network: 管理网络 ##②大多数 HPCC 系统配有两个网络 基于TCP的管理网络 计算网络，可以是基于 TCP 或其它协议的，通常是 InfiniBand 或 Myrinet 10G 之 类的高速网络##③拓扑图网上找的普遍认可的： 这个是自己根据实际情况“臆想”的： ##④所需软件组件（按安装顺序）： ###1、对于安装系统： 集群中的每个节点（HPCC 节点文章链接）、主节点、登录节点和计算节点都需要有操作系统。操作系统可以安装在节点的硬盘驱动器上，甚至可以安装在ramdisk 上，这有时被称为“无盘”或“无状态”节点。一般说来，主节点创建所谓的“映像”，然后将其发送到计算节点上进行安装（硬盘驱动器或 ramdisk 上）。 系统装在内存会更快，但断电后要采取将系统拷贝到硬盘的方法重新存储起来，比较麻烦。 几种安装工具的特点： 但是，比较有名有Rocks（比xCat安装简单）、xCat。 xCAT:a、支持自己系统独立，可以自己选择基于RHEL的最新版本系统；b、命令行安装，需要人工编辑配置文件，安装一台之后再利用脚本进行网络安装裸机节点；c、xCat在安装起来像一个个独立软件，如其他并行计算需要的相关软件可以通过xCat命令安装； Rocks:a、ROCKS 基于 Red Hat 发行版，这对于大多数人是合适的，但是对于使用 SUSE 或者希望使用在 RH 6.2 发行版上创建的映像的人就不合适了，里面的软件可以选择性安装。另外，ROCKS 不是克隆解决方案；b、之前需刻录CD，GUI界面部署，之后人工进行节点命名和节点ip的配置，安装时一台一台进行；c、Rocks则像一个集成的包，包含工具与软件；Rocks = CentOS + RollsRoll软件包包括： base：基本的Rocks Cluster管理工具 SGE：SUN Grid Engine，集群下作业调度 HPC：为集群上的并行应用提供运行环境（MPI，PVM） area51：分析集群上文件和内核的完整性 Ganglia：集群监控软件（主流hpc cluster基本都有这个） Bio：集群的生物信息学工具 一般而言，这两种方法只有适用性与便捷性的差异。有一个视频课程 http://edu.51cto.com/course/course_id-507.html 对于操作系统的选择，调研了很多，一般用Red Hat，Centos居多，一方面是社区活跃，一方面是源码开发，资源兼容较多。（MIC开发上基本采用Red Hat，Centos，SUSE，windows也开始有了） ###2、安装驱动和开发工具。包括IB驱动、编译器、编辑器、调试器、库等。 并行计算开发环境： 安装英特尔众核平台软件堆栈(MPSS)，包含各种驱动。https://software.intel.com/en-us/articles/intel-manycore-platform-software-stack-mpss#lx34rel 假如用intel的编译器的话（我们应该是用intel的）：下载安装intel parallel studio xe 2015，包含有性能分析工具、编译器、高性能库、并行编程工具等，对Xeon Phi进行相应的优化和升级。 Cilk Plus，OpenMP，TBB多线程编程技术和向量化技术在Xeon &amp; Xeon Phi上都已实现了，软件开发者无需额外的移植成本。（试用30天）https://software.intel.com/en-us/intel-parallel-studio-xe/try-buy xeon phi与第三方工具是否available，参考Intel FAQ：https://software.intel.com/en-us/articles/intel-and-third-party-tools-and-libraries-available-with-support-for-intelr-xeon-phitm ###3、配置节点信息存储系统安装NFS、PVFS、Lustre 、Luster、GPFS、SNFS等，一般大型的HPC集群用Lustre能获得更好的性能，但不太适合小集群，小集群可以考虑用NFS和PVFS，但NFS并不是面向并行计算的，推荐用PVFS好一点。 关于Lustre： 一个Lustre文件系统主要包括以下四个组件：管理服务器Management Server(mgs), 元数据服务器Meta Data Target(mdt), 对象存储服务器Object Storge Target(ost) ,客户端Lustre clients(lc)。 它主要包括三个部分：元数据服务器MDS (Metadata Server)、对象存储服务器OSS (Object Storage Server)和客户端Client。 正常的启动顺序是：OST -&gt; MDS -&gt; CLIENT 甲骨文产品管理负责人Bob Thome表示：“云文件系统并不是甲骨文首个基于集群文件系统的产品。甲骨文管理着Lustre项目，Lustre更适合于拥有上千台服务器的大规模HPC（高性能计算）部署。云文件系统则更适合于25个节点数左右的小规模部署，尽管Lustre已经通过了多达100个节点的测试。Lustre也可以实现很多相同的功能，但使用门槛较高，安装和配置较为繁琐，并不适合于小规模部署。” 关于Lustre的博文：http://www.cnblogs.com/jpa2/category/384788.html PVFS存在以下不足：1）单一管理节点。上面说到过PVFS中只有一个管理节点来管理元数据，当集群系统达到一定的规模之后，管理节点将可能出现过度繁忙的情况，这时管理节点将成为系统瓶颈。2）对数据的存储缺乏容错机制。当某一I/O节点无法工作时，上面的数据将出现不可用的情况。3）静态配置。对PVFS的配置只能在启动前进行，一旦系统运行则不可再更改原先的配置。 ###4、集群管理工具（考虑是否集成了一些组件） 集群管理工具 (CMT)，它的职能是管理集群。它有多个功能，有的是可选功能。而必须具备的功能包括: 维护计算节点清单（即集群中包括的节点）。只需通过简单如 /etc/hosts 的，就能复制或通过本地 DNS 发送至每个计算节点 创建、管理映像或安装在计算节点上的数据包集 发送映像或数据包到计算节点（一般通过 PXE ） 执行对计算节点的基本监控（例如，节点工作情况？什么节点发生起落？） 计算节点电源控制（不是硬性要求，但是强烈推荐）。即远程开启/关闭节点，此功能可以通过各种方法实现，有的方法需要使用增加其他硬件。 虽然这个功能清单对于有集群经验的人来说显得太简短，但清单所载功能是 CMT真正的核心。具备其他功能也不错，但对集群来说并不是必不可少的。 CMT 包括 Platform OCS、Clustercorp ROCKS+、Microsoft Windows CCS 和平台管理器 (Platform Manager) 、Mon等。 ###5、可选组件： 集群所需的工具并不多，但有了这些就能实现集群的基本运行。不过，它只能满足 1 个用户或 2 至 3 个用户的需要，此外，要实现全面控制和掌握集群的运行情况。要安装一些可选组件，从技术上虽然是可选项，但是没有这些工具，集群就不具备生产能力。有一些组件可以添加到 CMT 或 CMI 上层。一个有数年管理多个集群经验的人说的，强烈建议您郑重考虑使用以下附加组件： 更加广泛的监控工具，包括集群状态图形视图，例如Ganglia（链接- http://ganglia.info/）、Cacti（链接 - http://www.cacti.net/）和 Nagios（链接 -http://www.nagios.org/) 报告工具，允许您创建关于集群运行情况的报告 用户帐户管理工具（允许您在整个集群上创建用户帐号、允许用户设置密码，然后将其传播到集群的所有节点上，允许无密码登录节点，这对于运行 MPI 应用程序是必需的） 另一个理论上可选，但值得强烈推荐的组件——任务调度器（也被称为资源管理器）任务调度器是一个允许用户提交执行任务、但不参与任务运行的排队系统。任务调度器把提交的任务排成队列，等到资源（即节点）可用时，就开始运行。任务调度器包括：Platform LSF、PBS-Pro 和 MOAB 等。 ###6、测试略 #三、参考链接：http://www.ibm.com/developerworks/cn/linux/l-cluster1/http://zh.community.dell.com/techcenter/w/techcenter_wiki/50http://www.hpcblog.com.cn/ 附上一张高清MIC图：","categories":[{"name":"HPC","slug":"HPC","permalink":"https://scutccnl.github.io/categories/HPC/"}],"tags":[{"name":"cluster","slug":"cluster","permalink":"https://scutccnl.github.io/tags/cluster/"}]},{"title":"HPC性能测试","slug":"hpc-benchmark","date":"2015-03-24T06:43:00.000Z","updated":"2016-07-16T06:35:11.694Z","comments":true,"path":"2015/03/24/hpc-benchmark/","link":"","permalink":"https://scutccnl.github.io/2015/03/24/hpc-benchmark/","excerpt":"#一、介绍 说到高性能计算，一般都是利用搭建集群配合加速卡做并行计算实现。但用相同的硬件实现更快的方法，那就是做测试了。比较有名的就是Linpack测试了，Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark，在高性能领域，就是利用其中的HPL测试进行测试。下面摘一段百科上的解释:","text":"#一、介绍 说到高性能计算，一般都是利用搭建集群配合加速卡做并行计算实现。但用相同的硬件实现更快的方法，那就是做测试了。比较有名的就是Linpack测试了，Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark，在高性能领域，就是利用其中的HPL测试进行测试。下面摘一段百科上的解释: Linpack现在在国际上已经成为最流行的用于测试高性能计算机系统浮点性能的benchmark。通过利用高性能计算机，用高斯消元法求解N元一次稠密线性代数方程组的测试，评价高性能计算机的浮点性能。 Linpack测试包括三类，Linpack100、Linpack1000和HPL。Linpack100求解规模为100阶的稠密线性代数方程组，它只允许采用编译优化选项进行优化，不得更改代码，甚至代码中的注释也不得修改。Linpack1000要求求解规模为1000阶的线性代数方程组，达到指定的精度要求，可以在不改变计算量的前提下做算法和代码上做优化。HPL即High Performance Linpack，也叫高度并行计算基准测试，它对数组大小N没有限制，求解问题的规模可以改变，除基本算法（计算量）不可改变外，可以采用其它任何优化方法。前两种测试运行规模较小，已不是很适合现代计算机的发展，因此现在使用较多的测试标准为HPL，而且阶次N也是linpack测试必须指明的参数。 HPL是针对现代并行计算机提出的测试方式。用户在不修改任意测试程序的基础上，可以调节问题规模大小N(矩阵大小)、使用到的CPU数目、使用各种优化方法等来执行该测试程序，以获取最佳的性能。HPL采用高斯消元法求解线性方程组。当求解问题规模为N时，浮点运算次数为(2/3 N^3－2N^2)。因此，只要给出问题规模N，测得系统计算时间T，峰值=计算量(2/3 N^3－2N^2)/计算时间T，测试结果以浮点运算每秒（Flops）给出。 计算峰值： 随着产品硬件的不断的升级，整个的计算能力也以数量级的速度提升。衡量计算机性能的一个重要指标就是计算峰值，例如浮点计算峰值，它是指计算机每秒钟能完成的浮点计算最大次数。包括理论浮点峰值和实测浮点峰值： 理论浮点峰值是该计算机理论上能达到的每秒钟能完成浮点计算最大次数，它主要是由CPU的主频决定的，理论浮点峰值=CPU主频×CPU每个时钟周期执行浮点运算的次数×系统中CPU核心数目 实测浮点峰值是指Linpack测试值，也就是说在这台机器上运行Linpack测试程序，通过各种调优方法得到的最优的测试结果。实际上在实际程序运行过程中，几乎不可能达到实测浮点峰值，更不用说达到理论浮点峰值了。这两个值只是作为衡量机器性能的一个指标，用来表明机器处理能力的一个标尺和潜能的度量。 此次参加一个高性能的比赛，虽然做的是平台搭建部分，但对此也有些了解。也了解了一下HPCC测试和NAMD测试，下面主要分这两部分来说一下。 #二、正文 1、HPCC HPCC 全称 HPC Chanllenge Benchmark Benchmark 是指一组用来评估硬件或者软件相关性能的基准测试程序 HPC Chanllenge Benchmark 由一组benchmark组成，共计7个，分别测试了系统7个方面的性能，这7个分别为： HPL stream Random Access PTRANS, Latency/Bandwidth FFT DGEMM stream：测试内存带宽内存看作是内存控制器与CPU之间的桥梁与仓库。内存的容量决定“仓库”的大小，而内存的带宽决定“桥梁”的宽窄Random Access：测试内存刷新的速率（随机存储中电容器需要刷新）PTRANS：通过多处理器结构中两两之间的通信，来衡量在整个网络的通信能力Latency/Bandwidth：测试延时与带宽 Latency：8 byte 数据从一个节点到另一个节点所需时间 Bandwidth：节点间网络通信的带宽 HPL：测试系统在解线性方程组时进行浮点运算的性能 浮点运算：超级计算机应用的场景主要是在科学计算，经常涉及矩阵运算、各种数值模拟等。 超级计算机经常以FLOPS（每秒浮点运算次数）去衡量计算能力 HPCC里有3种benchmark是测试浮点计算性能的 FFT：涉及到双精度一维离散傅里叶变换时，浮点运算的速度DGEMM：在做双精度矩阵乘法时，浮点运算的速度 HPCC的下载地址见：链接 这个软件13年8月后就没更新了，网上查阅了很多资料，发现使用的人好像也不多，对于高性能计算，大多都是HPL的文章和测试。要想使用好这个软件，需要研读其源代码。 其中的安装使用方法可参照网站的FAQ以及软件中的README.html 编译之前，需要下载好相关的库，包括MPI（mpich，mpich2，mvapich，openmpi，platform_mpi，hpmpi……）、MKL/BLAS/GotoBLAS2……、C语言编译器等，前两者集群一般需要自己去找对应的软件，详细配置请自行上网搜一下，和Linpack基本一样。 ###2、NAMD测试 NAMD是一个与分子动力学有关，用来高仿真大型生物分子系统的程序。即生物分子建模程序。 现提供两个工作负载apoa1, f1atpase 它们可以从 http://www.ks.uiuc.edu/Research/namd/utilities/f1atpase.tar.gz和http://www.ks.uiuc.edu/Research/namd/utilities/apoa1.tar.gz下载。 至于性能的话，且看图： 图片来源：链接 NAMD 2.8 在天津超算天河-1A上的测试结果： 表1 每节点不同进程数以及使用不同节点数的NAMD性能（days/ns）比较 结论：为了在天河上达到性能最优，最佳的方案是使用GPU，并且每个节点开6个进程。参照：链接","categories":[{"name":"HPC","slug":"HPC","permalink":"https://scutccnl.github.io/categories/HPC/"}],"tags":[{"name":"benchmark","slug":"benchmark","permalink":"https://scutccnl.github.io/tags/benchmark/"}]},{"title":"学习感悟","slug":"study-thinking-20150319","date":"2015-03-19T05:42:00.000Z","updated":"2016-07-16T06:35:11.722Z","comments":true,"path":"2015/03/19/study-thinking-20150319/","link":"","permalink":"https://scutccnl.github.io/2015/03/19/study-thinking-20150319/","excerpt":"社会篇 走过2014，看得很多是互联网如何在颠覆各个行业。以下说的都是感悟，可能有些无序，多多包含。 无论是做科研也好，投入社会工作也罢，在做以互联网技术为核心的技术学习时，都要有一个目标，做出为社会认可的有价值的“产品”，并间接体现为金钱财富。","text":"社会篇 走过2014，看得很多是互联网如何在颠覆各个行业。以下说的都是感悟，可能有些无序，多多包含。 无论是做科研也好，投入社会工作也罢，在做以互联网技术为核心的技术学习时，都要有一个目标，做出为社会认可的有价值的“产品”，并间接体现为金钱财富。 其实，互联网从访问互联网的用户中赚钱，流量即是渠道。曾听过一句话——“有流量就能赚钱”。确实，在各个行业环环相扣的时候，利用“代理”的作用能把流量转化为金钱，也由于这个原因，才使那么多网民孜孜不倦地以合法或不合法的手段游走于因特网各个角落。 然而，怎样最高效率地利用流量，叫要看个人的素养，假如我们将单纯上网的网民比作现实中普通的消费者，那么单纯利用流量赚钱可以比作打工者，而管理某个访问点的可以比作房东，那么房地产，设计师又如何？那需要有强大编程功底的各个阶层的创作者来担任了。从做服务，到做标准，互联网是另一个世界，虚拟而却又像现实生活中那样分工明确，生活着。 在这里，我相信都想往高处走，做创作者。但这里我有个发现，能做到标准的少之又少，多数成功者，走的却是先往高处走，当走到一定规模后，市场足够大，再往低处走，做稳定发展的打算。之后有余力再在高处不断试探，不断阶梯式上升，建造更高的高峰。 14年相比13年又可以称为互联网的爆炸阶段，不管是从从业的数量来看还是从创业的数量来看。一切的发展归根到底都是为了服务人类生活，往更便捷更智能更廉价发展。 因此，才涌现了更方便的产品，更智能的算法，更高速的计算。 #热点篇 更方便的产品，更智能的算法，更高速的计算，既是相对分开，却又是一脉相承，任何一个领域都可以颠覆另一个领域，当然，最终体现在产品上， 因而产品领域是最活跃的，门槛相对低的情况下又与金钱结合得最为紧密。而超算方面一直以来都比较冷门，毕竟门槛高，又与硬件运算最为相关 说到产品，苹果、谷歌、Facebook，产品之王|搜索之王|社交之王。 说到算法，目前人工智能领域的机器学习，深度学习，还有相关的大数据，云计算等。 说到计算，那就是超算，高性能计算，单台配上GPU和MIC可以提升计算能力，或者直接在集群上并行。 这三种内容在以后的博客应该都会多多少少体现。 #学习篇 慢慢啃，从实验到产品，是一个漫长的过程，但所有的收获，都是从test开始的，或许从产品着手不需要多高的理论积累，在这个风口也完全有可能飞得老高，所以才一家家公司冒出来，或者一些资深程序员直接跳出来创业。说实在，最后能将厚积理论勃发在产品的，互联网大公司才做得最好，毕竟资金人力都全了。小公司或者突然强势冒出来，大有盖过大公司风头之势，但大多昙花一现、干不过大公司，最后被收购也不是少例。虽说这样足够混迹互联网圈，但能主导一个潮流，不算是人生的一大乐事吗？","categories":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/tags/life/"}]},{"title":"【machine learning】KNN算法        ","slug":"machinelearning-KNN","date":"2015-02-25T08:04:00.000Z","updated":"2016-07-16T06:35:11.702Z","comments":true,"path":"2015/02/25/machinelearning-KNN/","link":"","permalink":"https://scutccnl.github.io/2015/02/25/machinelearning-KNN/","excerpt":"适逢学习机器学习基础知识，就将书中内容读读记记，本博文代码参考书本Machine Learning in Action（《机器学习实战》）。 一、概述kNN算法又称为k近邻分类(k-nearest neighbor classification)算法。 kNN算法则是从训练集中找到和新数据最接近的k条记录，然后根据他们的主要分类来决定新数据的类别。该算法涉及3个主要因素：训练集、距离或相似的衡量、k的大小。","text":"适逢学习机器学习基础知识，就将书中内容读读记记，本博文代码参考书本Machine Learning in Action（《机器学习实战》）。 一、概述kNN算法又称为k近邻分类(k-nearest neighbor classification)算法。 kNN算法则是从训练集中找到和新数据最接近的k条记录，然后根据他们的主要分类来决定新数据的类别。该算法涉及3个主要因素：训练集、距离或相似的衡量、k的大小。 二、算法要点1、指导思想kNN算法的指导思想是“近朱者赤，近墨者黑”，由你的邻居来推断出你的类别。 计算步骤如下：1）算距离：给定测试对象，计算它与训练集中的每个对象的距离2）找邻居：圈定距离最近的k个训练对象，作为测试对象的近邻3）做分类：根据这k个近邻归属的主要类别，来对测试对象分类 2、距离或相似度的衡量什么是合适的距离衡量？距离越近应该意味着这两个点属于一个分类的可能性越大。距离衡量包括欧式距离、夹角余弦等。对于文本分类来说，使用余弦(cosine)来计算相似度就比欧式(Euclidean)距离更合适。 3、类别的判定投票决定：少数服从多数，近邻中哪个类别的点最多就分为该类，属于以频率为标准。加权投票法：根据距离的远近，对近邻的投票进行加权，距离越近则权重越大（权重为距离平方的倒数），属于以量化为标准。 三、优缺点1、优点简单，易于理解，易于实现，无需估计参数，无需训练适合对稀有事件进行分类（例如当流失率很低时，比如低于0.5%，构造流失预测模型）特别适合于多分类问题(multi-modal,对象具有多个类别标签)，例如根据基因特征来判断其功能分类，kNN比SVM的表现要好 2、缺点懒惰算法，对测试样本分类时的计算量大，内存开销大，评分慢可解释性较差，无法给出决策树那样的规则。 四、利用KNN进行手写识别假如存在训练数据，都是二值得灰度图，来源于手写面板的采集图像数据。如下表示数字‘0’，所在文件夹下包括表示0~9的文件，文件夹命名A_B.txt,A表示真实数字，B表示该数字的第B个样本（一般数据越多有有利于接近预测值） 在另一个文件夹中，也存在同样命名的数据文件，用于检验有监督学习下的准确率，我们称为测试数据。在代码中，我们需要三个函数 def classify0(inX, dataSet, labels, k)——用于对输入单个样本inX进行分类，dataSet为训练数据，labels为训练数据的类别，K为近邻范围def img2vector(filename)——将文件filename中的数据规格由32X32转换为1X1024的向量def handwritingClassTest()——利用测试数据进行测试，得出错误率我这里只用了0~9分别20个训练数据而已，提高速度。需要源代码可以到机器学习实战的配套代码中取 http://vdisk.weibo.com/s/uEZesAafcjQgx?sudaref=www.baidu.com 代码中用到了numpy库，numpy库用在数据量大的计算较高效 numpy用法小抄：123456&gt;&gt;&gt; tile([0, 0], (1, 2))array([[0, 0, 0, 0]])&gt;&gt;&gt; tile([0, 0], (2, 1))array([[0, 0], [0, 0]])` 第一个是矩阵A第二个参数是要 只有一个数字时，表示 对 A中元素重复的次数两个参数时（x， y） y表示对A中元素重复的次数， x表示 对前面的操作执行x次。 12345678910111213&gt;&gt;&gt; b= np.arange(12).reshape(3,4)&gt;&gt;&gt; barray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt; b.sum(axis=0) # 计算每一列的和，注意理解轴的含义，参考数组的第一篇文章array([12, 15, 18, 21])&gt;&gt;&gt; b.min(axis=1) # 获取每一行的最小值array([0, 4, 8])&gt;&gt;&gt; b.cumsum(axis=1) # 计算每一行的累积和array([[ 0, 1, 3, 6], [ 4, 9, 15, 22], [ 8, 17, 27, 38]]) 需要用到再另外写博客进行补充。KNN.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#! /usr/bin/env python#coding=utf-8from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): #inX------[x,x,x,x] #dataSet------array([[x,x,x,x],[x,x,x,x]]) #labels------[x,x] #k------n dataSetSize = dataSet.shape[0] diffMat = tile(inX, (dataSetSize,1)) - dataSet sqDiffMat = diffMat**2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances**0.5 sortedDistIndicies = distances.argsort() classCount=&#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndicies[i]] classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 #将字典按value值大小降序排序,结果为二维列表 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0]def img2vector(filename): returnVect = zeros((1,1024)) fr = open(filename,'r') for i in range(32): lineStr = fr.readline() for j in range(32): returnVect[0,32*i+j] = int(lineStr[j]) return returnVecttrainFile = 'F:\\\\python\\\\pyproject\\\\ML\\\\codes\\\\machinelearninginaction\\\\Ch02\\\\training20\\\\'testFile = 'F:\\\\python\\\\pyproject\\\\ML\\\\codes\\\\machinelearninginaction\\\\Ch02\\\\testDigits\\\\'def handwritingClassTest(): hwLabels = [] trainingFileList = listdir(trainFile) #load the training set m = len(trainingFileList) trainingMat = zeros((m,1024)) for i in range(m): fileNameStr = trainingFileList[i] fileStr = fileNameStr.split('.')[0] #take off .txt classNumStr = int(fileStr.split('_')[0]) hwLabels.append(classNumStr) path = trainFile + '%s' trainingMat[i,:] = img2vector(path % fileNameStr) testFileList = listdir(testFile) #iterate through the test set errorCount = 0.0 mTest = len(testFileList) for i in range(mTest): fileNameStr = testFileList[i] fileStr = fileNameStr.split('.')[0] #take off .txt classNumStr = int(fileStr.split('_')[0]) path = testFile + '%s' vectorUnderTest = img2vector(path % fileNameStr) classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, 3) print \"the classifier came back with: %d, the real answer is: %d\" % (classifierResult, classNumStr) if (classifierResult != classNumStr): errorCount += 1.0 print \"\\nthe total number of errors is: %d\" % errorCount print \"\\nthe total error rate is: %f\" % (errorCount/float(mTest)) 再在test.py中调用KNN.handwritingClassTest()，则程序开始运行 test.py 12345#! /usr/bin/env python#coding=utf-8import KNNKNN.handwritingClassTest() 可看到错误率10.68%，挺高的，增加训练数据量就应该会减小一些。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://scutccnl.github.io/categories/Machine-Learning/"}],"tags":[{"name":"ML foundation","slug":"ML-foundation","permalink":"https://scutccnl.github.io/tags/ML-foundation/"},{"name":"classifier","slug":"classifier","permalink":"https://scutccnl.github.io/tags/classifier/"}]},{"title":"网络爬虫框架scrapy介绍及应用——抓取新浪新闻的标题内容评论        ","slug":"python-scrapy","date":"2015-01-21T07:12:00.000Z","updated":"2016-07-16T06:35:11.718Z","comments":true,"path":"2015/01/21/python-scrapy/","link":"","permalink":"https://scutccnl.github.io/2015/01/21/python-scrapy/","excerpt":"一、综述 开始这篇博文之前，调研了相关的爬虫方法，简单罗列冰山一角。 综述： http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/","text":"一、综述 开始这篇博文之前，调研了相关的爬虫方法，简单罗列冰山一角。 综述： http://www.crifan.com/summary_about_flow_process_of_fetch_webpage_simulate_login_website_and_some_notice/ 手动编写爬虫，httpclient是常用工具。常见的请求方式有httpget和httppost http://blog.csdn.net/mr_tank_/article/details/17454315 http://blog.csdn.net/chszs/article/details/16854747 http://www.yeetrack.com/?p=779 这个教程很全面。供参考和备查 htmlunit httpclient 对js 的支持比较差，有时候需要使用htmlunit 或者selenium。 http://www.360doc.com/content/13/1229/14/14875906_340995211.shtml http://blog.csdn.net/strawbingo/article/details/5768421 http://www.cnblogs.com/microsoftmvp/p/3716750.html 抽取相关当爬取了html 后，需要去除噪声广告，抽取有用的信息。jsoup 和tika 是非常强大的工具 http://jsoup.org/cookbook/ http://summerbell.iteye.com/blog/565922 github开源爬虫库 https://github.com/CrawlScript/WebCollector https://github.com/zhuoran/crawler4j 开源爬虫框架nutch http://www.cnblogs.com/xuekyo/archive/2013/04/18/3028559.html http://ahei.info/nutch-tutorial.htm http://lc87624.iteye.com/blog/1625677 由于要学习python语言，就关注了python爬虫的方法，scrapy框架是个成熟的开源爬虫框架，因此选择其作为学习内容。Scrapy是一个基于Twisted，纯Python实现的爬虫框架，用户只需要定制开发几个模块就可以轻松的实现一个爬虫，用来抓取网页内容、图片、视频等，非常方便。 二、scrapy框架1、整体架构如下： 绿线是数据流向，首先从初始URL 开始，Scheduler 会将其交给 Downloader 进行下载，下载之后会交给 Spider 进行分析，Spider分析出来的结果有两种：一种是需要进一步抓取的链接， 例如之前分析的“下一页”的链接，这些东西会被传回 Scheduler ；另一种是需要保存的数据，它们则被送到Item Pipeline 那里，那是对数据进行后期处理（详细分析、过滤、存储等）的 地方。另外，在数据流动的通道里还可以安装各种中间件，进行必要的处理。参考 博客 2、工程文件介绍假设你已经配置好环境了，进入某个文件夹pythonproject，在命令行中输入scrapy startproject mypro即可在pythonporoject文件夹下找到mypro的工程文件夹，结构如下： ├── mypro│ ├── mypro│ │ ├── init.py│ │ ├── items.py│ │ ├── pipelines.py│ │ ├── settings.py│ │ └── spiders│ │ └── init.py│ └── scrapy.cfg scrapy.cfg: 项目配置文件items.py: 需要提取的数据结构定义文件pipelines.py:管道定义，用来对items里面提取的数据做进一步处理，如保存等settings.py: 爬虫配置文件 Items是将要装载抓取的数据的容器，它工作方式像python里面的字典，但它提供更多的保护，比如对未定义的字段填充以防止拼写错误。它通过创建一个scrapy.item.Item类来声明，定义它的属性为scrpiy.item.Field对象，就像是一个对象关系映射(ORM)，我们通过将需要的item模型化，来控制从dmoz.org获得的站点数据。虽然这次的实现并没有用到items.py和 pipelines.py，但大规模的爬虫还是需要注意一下解耦。举个例子： 12345from scrapy.item import Item, Field class DmozItem(Item): title = Field() link = Field() desc = Field() 在修改初始化代码时，首先需要在pythonproject//mypro//mypro//spiders下新建一个python文件，原则上所有的实现可以在这个文件里完成，当然耦合度就高了。在这个文件中，你需要新 建一个类，这个类需要添加以下属性：1、该类继承于某个spider类，根据自己的需求，有很多可以选，如crawSpider，BaseSpider，Spider，XMLFeedSpider，CSVFeedSpider，SitemapSpider等等2、name：爬虫的识别名，它必须是唯一的，在不同的爬虫中你必须定义不同的名字，例如下文的”yourname”3、start_urls：爬虫开始爬的一个URL列表。爬虫从这里开始抓取数据，所以，第一次下载的数据将会从这些URLS开始。其他子URL将会从这些起始URL中继承性生成。4、parse()：爬虫的方法，调用时候传入从每一个URL传回的Response对象作为参数，response将会是parse方法的唯一的一个参数，这个方法负责解析返回的数据、匹配抓取的数据(解析为 item)并跟踪更多的URL。返回前可以巧妙地运用yield方法递归调用网址，此关键词的作用是返回某个对象后继续执行。如果不用该关键字，则直接会在函数中返回。 一般而言，运用scrapy的步骤是这样的：1、在pythonproject//mypro//mypro//spiders下新建一个python文件2、导入该导入的库文件，新建一个类满足以上要求。3、根据继承的类的要求和功能，定义爬取规则。4、在def parse(self, response)函数中对response对象解析，将需要的内容存入item对象并返回，在这里对数据不返回而是进行进一步处理也是可以的，耦合度高。5、PipeLine用来对Spider返回的Item列表进行保存操作，可以写入到文件、或者数据库等。PipeLine只有一个需要实现的方法：process_item。万事具备之后，通过命令行进入pythonproject//mypro文件夹中，敲下命令行开始爬虫scrapy crawl “yourname”scrapy命令罗列几个，要更多请参看doc scrapy startproject xxx 新建一个xxx的project scrapy crawl xxx 开始爬取，必须在project中 scrapy shell url 在scrapy的shell中打开url，非常实用 scrapy runspider &lt;spider_file.py&gt; 可以在没有project的情况下运行爬虫 三、新浪新闻爬虫众所周知，评论一般是隐藏起来的，或者显示部分，需要手动点击加载去获取更多评论。有两种方法可以解决这种方法，一种是利用js动态解析，工作量大，也比较难实现，二是直接定位到其查询数据库的url，直接抽取。下文就是讲第二种方法。新浪页面导航为我们简单分好类了http://news.sina.com.cn/guide/，而且每个类别中都可以找到相应的滚动新闻（url冠以roll），因而没必要用到crawSpider这个类，这个类功能很强大，不仅可以自动去重，还可以定义更多的爬取规则。例如这个链接http://roll.finance.sina.com.cn/finance/zq1/index_1.shtml，通过修改数字可以实现不断爬取对于新闻的url，当然没有这么“好”的url也是可以找到新闻的url。例如：http://sports.sina.com.cn/nba/可以调用的浏览器的开发工具查找对应的js代码，查看数据库的url，之后在查看评论的时候也是这样的方法（点击刷新即可） 访问这个链接可以查看url 因此，访问这个链接的内容，爬取新闻url,访问新闻并爬取标题、内容、评论。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222#! /usr/bin/env python #coding=utf-8 from scrapy.selector import Selector from scrapy.http import Request import re,os from bs4 import BeautifulSoup from scrapy.spider import Spider import urllib2,thread #处理编码问题 import sys reload(sys) sys.setdefaultencoding('gb18030') #flag的作用是保证第一次爬取的时候不进行单个新闻页面内容的爬取 flag=1 projectpath='F:\\\\Python27\\\\pythonproject\\\\fuck\\\\' def loop(*response): sel = Selector(response[0]) #get title title = sel.xpath('//h1/text()').extract() #get pages pages=sel.xpath('//div[@id=\"artibody\"]//p/text()').extract() #get chanel_id &amp; comment_id s=sel.xpath('//meta[@name=\"comment\"]').extract() #comment_id = channel[index+3:index+15] index2=len(response[0].url) news_id=response[0].url[index2-14:index2-6] comment_id='31-1-'+news_id #评论内容都在这个list中 cmntlist=[] page=1 #含有新闻url,标题,内容,评论的文件 file2=None #该变量的作用是当某新闻下存在非手机用户评论时置为False is_all_tel=True while((page==1) or (cmntlist != [])): tel_count=0 #each page tel_user_count #提取到的评论url url=\"http://comment5.news.sina.com.cn/page/info?version=1&amp;format=js&amp;channel=cj&amp;newsid=\"+str(comment_id)+\"&amp;group=0&amp;compress=1&amp;ie=gbk&amp;oe=gbk&amp;page=\"+str(page)+\"&amp;page_size=100\" url_contain=urllib2.urlopen(url).read() b='=&#123;' after = url_contain[url_contain.index(b)+len(b)-1:] #字符串中的None对应python中的null，不然执行eval时会出错 after=after.replace('null','None') #转换为字典变量text text=eval(after) if 'cmntlist' in text['result']: cmntlist=text['result']['cmntlist'] else: cmntlist=[] if cmntlist != [] and (page==1): filename=str(comment_id)+'.txt' path=projectpath+'stock\\\\' +filename file2=open(path,'a+') news_content=str('') for p in pages: news_content=news_content+p+'\\n' item=\"&lt;url&gt;\"+response[0].url+\"&lt;/url&gt;\"+'\\n\\n'+\"&lt;title&gt;\"+str(title[0])+\"&lt;/title&gt;\\n\\n\"+\"&lt;content&gt;\\n\"+str(news_content)+\"&lt;/content&gt;\\n\\n&lt;comment&gt;\\n\" file2.write(item) if cmntlist != []: content='' for status_dic in cmntlist: if status_dic['uid']!='0': is_all_tel=False #这一句视编码情况而定，在这里去掉decode和encode也行 s=status_dic['content'].decode('UTF-8').encode('GBK') #见另一篇博客“三张图” s=s.replace(\"'\"\"'\",'\"') s=s.replace(\"\\n\",'') s1=\"u'\"+s+\"'\" try: ss=eval(s1) except: try: s1='u\"'+s+'\"' ss=eval(s1) except: return content=content+status_dic['time']+'\\t'+status_dic['uid']+'\\t'+ss+'\\n' #当属于手机用户时 else: tel_count=tel_count+1 #当一个page下不都是手机用户时，这里也可以用is_all_tel进行判断，一种是用开关的方式，一种是统计的方式 #算了不改了 if tel_count!=len(cmntlist): file2.write(content) page=page+1 #while loop end here if file2!=None: #当都是手机用户时，移除文件，否则写入\"&lt;/comment&gt;\"到文件尾 if is_all_tel: file2.close() try: os.remove(file2.name) except WindowsError: pass else: file2.write(\"&lt;/comment&gt;\") file2.close() class DmozSpider(Spider): name = \"stock\" allowed_domains = [\"sina.com.cn\"] #在本程序中，start_urls并不重要，因为并没有解析 start_urls = [ \"http://news.sina.com.cn/\" ] global projectpath if os.path.exists(projectpath+'stock'): pass else: os.mkdir(projectpath+'stock') def parse(self, response): #这个scrapy.selector.Selector是个不错的处理字符串的类，python对编码很严格，它却处理得很好 #在做这个爬虫的时候，碰到很多奇奇怪怪的编码问题，主要是中文，试过很多既有的类，BeautifulSoup处理得也不是很好 sel = Selector(response) global flag if(flag==1): flag=2 page=1 while page&lt;260: url=\"http://roll.finance.sina.com.cn/finance/zq1/index_\" url=url+str(page)+\".shtml\" #伪装为浏览器 user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' headers = &#123; 'User-Agent' : user_agent &#125; req = urllib2.Request(url, headers=headers) response = urllib2.urlopen(req) url_contain = response.read() #利用BeautifulSoup进行文档解析 soup = BeautifulSoup(url_contain) params = soup.findAll('div',&#123;'class':'listBlk'&#125;) if os.path.exists(projectpath+'stock\\\\'+'link'): pass else: os.mkdir(projectpath+'stock\\\\'+'link') filename='link.txt' path=projectpath+'stock\\\\link\\\\' + filename filelink=open(path,'a+') for params_item in params: persons = params_item.findAll('li') for item in persons: href=item.find('a') mil_link= href.get('href') filelink.write(str(mil_link)+'\\n') #递归调用parse,传入新的爬取url yield Request(mil_link, callback=self.parse) page=page+1 #对单个新闻页面新建线程进行爬取 if flag!=1: if (response.status != 404) and (response.status != 502): thread.start_new_thread(loop,(response,)) 爬取结果： 在爬取的过程中要注意三点：1.爬取不要过于频繁，不然可能会被封ip，可以减小爬取的速度，sleep一下，或者更改设置文件，我的在F:\\Python27\\python\\Lib\\site-packages\\Scrapy-0.24.4-py2.7.egg\\scrapy\\settings\\default_settings.py2.文件夹的文件上限为21845，超过后注意再新建一个文件夹爬取3.线程不能开得太多，不然也可能达到上限，可以考虑用代码现在所开线程的多少或者利用分布式系统","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[{"name":"spider","slug":"spider","permalink":"https://scutccnl.github.io/tags/spider/"},{"name":"scrapy","slug":"scrapy","permalink":"https://scutccnl.github.io/tags/scrapy/"}]},{"title":"【machine learning】regularization        ","slug":"machinelearning-linear-regularization","date":"2015-01-21T06:57:00.000Z","updated":"2016-07-16T06:35:11.706Z","comments":true,"path":"2015/01/21/machinelearning-linear-regularization/","link":"","permalink":"https://scutccnl.github.io/2015/01/21/machinelearning-linear-regularization/","excerpt":"一、机器学习范式1、按数据类型划分(带标签与否)","text":"一、机器学习范式1、按数据类型划分(带标签与否) 这是从样本的数据进行划分，现实中大部分属于半监督学习，并且大部分数据是没分类好的。 监督学习： 例子： 分类 e.g. 文本分类 垃圾邮件过滤 搜索结果回归分析 e.g. 房价预测 股价预测序列标注 e.g. 词性标注 输入:“我中了一张彩票” 输出:“我/r 中/v 了/y /一/m /张/q /彩票/n 无监督学习： 例子：聚类 e.g. 热点话题发现 社团发现密度函数估计(probability density estimation ) e.g. pdf估计异常点检测(outlier detection) e.g. one-class SVM, 去噪 半监督学习： 核心思想考虑如何利用少量的标注样本和大量的未标注样本进行训练和分类的问题 例子：分类 e.g. 垃圾邮件过滤，半监督SVM回归分析聚类e.g. GMM 2、按学习过程划分主动学习、转导学习、强化学习 主动学习(Active Learning) 有少量标注的数据以及丰富的未标注数据 ，标注数据的成本很高，学习算法主动提出一些标注请求，将筛选过的数据交给专家进行标注，然后将标注的数据加入到训练集中，再进行训练。 核心问题：怎么样筛选数据才能使得请求标注的次数尽量少而最终的结果又尽量好 与半监督学习的区别：半监督学习算法不需要人工干预，基于自身对未标记数据加以利用，微博的用户推荐用户就是充当专家的角色。问题可形式化为： 转导学习(Transductive Learning)一种通过观察特定的训练样本，进而预测特定的测试样本的方法在不同的测试集上会产生相互不一致的预测 特点： 1.建立一个更适用于问题域的模型，而非一个更通用的模型 2.利用无标注的测试样本的信息发现聚簇，进而更有效地分类 3.模型近似 与半监督学习的区别：半监督学习不知道测试案例是什么，转导学习知道测试案 例是什么 半监督学习本质上是从特殊到一般(train)，一般到特殊(predict)的推理方法 转导学习本质上是直接从特殊到特殊的推理方法，自动修正模型。强化学习(Reinforcement Learning)从环境状态到行为映射的学习，以使系统行为从环境中获得的累积奖赏值最大。该方法不同与监督学习技术那样通过正例、反例来告知采取何种行为，而是通过试错（trial-and-error）的方法来发现最优行为策略 ）的方法来发现最优行为策略 适用情况：适用于序列决策或者控制问题，很难有这么规则的样本。 e.g. 象棋AI程序解决思路:我们设计一个回报函数（reward function），如果learning agent（象棋AI程序）在决定一步后，获得了较好的结果，那么我们给agent一些回报（比如回报函数结果为正），得到较差的结果，那么回报函数为负。如果我们能够对每一步进行评价，得到相应的回报函数，那么就好办了，我们只需要找到一条回报值最大的路径（每步的回报之和最大），就认为是最佳的路径。备注:一个强化学习的比赛 http://ijcai-15.org/index.php/angry-birds-competition 二、正则化1、模型选择： a.若采用多项式拟合 欠拟合(underfit,also high bias)特征集过小，模型过于简单，会导致训练集的误差明显增大的现象。 过拟合(overfit,also high variance)非常多的特征，那么所学的Hypothesis有可能对训练集拟合的非常好,但是对测试集效果很差，即训练误差少，测试集误差大。 b.避免过拟合的方法——约束高阶多项式的系数 以下是不同阶数的多项式相对应的系数 定义损失函数： 绿色曲线为最佳拟合，红色曲线为实际拟合结果。罚项系数选择 1.交叉验证 2.超参数学习，解决最优化问题 2、模型选择策略 a.代价函数(Cost function)b.风险函数或期望风险(risk function)① 定义为损失函数的期望② 理论上模型f(x)关于联合分布P(X, Y)的平均意义下的损失 ① 学习的本质目标是选择期望风险最小的模型，由于联合分布P(X,Y)是未知的，风险函数Rexp(f)不能直接计算。c.经验风险(empirical risk minimizatiion, ERM)①模型f(x)关于训练数据集的平均损失称为经验风险，对期望风险的近似 其实，最大似然估计等价于最小化经验风险。②经验风险最小化(ERM)的策略认为，经验风险最小的模型是最优模型③当样本容量是够大时，经验风险最小化能保证有很好的学习效果，在现实中被广泛应用④当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生“过拟合（over-fitting）”现象，如多项式阶数很大，出现过拟合。 d.结构风险(structural risk minimization, SRM)①在经验风险上加上表示模型复杂度的正则化项或罚项②防止过拟合 其中J(f)为模型的复杂度，是定义在假设空间 F 上的泛函数。模型 f 越复杂，复杂度J(f)就越大；反之，模型 f 越简单，复杂度J(f)就越小 ③决定了用以权衡经验风险和模型复杂度④结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测，正则化的本质是控制模型的复杂度。 3、贝叶斯公式 贝叶斯公式反映人们推理的方式,即人做实验时，先需要作出一定的假设(利用先验知识)，在假设的指导上去做实验，得到观察数据，最后利用实验数据修正对假设的理解，也就得到后验分布。 最小二乘问题的最大后验估计(MAP)令 最大后验估计等价于最小化正则化的平方损失函数，最大后验估计等价于最小化结构风险。代价函数可改成： 回顾下不加正则化的正规方程 加正则化的正规方程，相当于对矩阵所有特征值同时加了，新矩阵基本上是可逆的(除非原矩阵存在负的特征)，即新的特征方程有唯一解。因而利用贝叶斯的正则化是分类算法中常用的方法。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://scutccnl.github.io/categories/Machine-Learning/"}],"tags":[{"name":"ML foundation","slug":"ML-foundation","permalink":"https://scutccnl.github.io/tags/ML-foundation/"}]},{"title":"我唱自己的歌","slug":"songsong","date":"2015-01-20T13:30:26.000Z","updated":"2016-07-16T06:35:11.718Z","comments":true,"path":"2015/01/20/songsong/","link":"","permalink":"https://scutccnl.github.io/2015/01/20/songsong/","excerpt":"我唱自己的歌在布满车前草的道路上在灌木的集市上在雪松和白桦树的舞会上在那山野的原始欢乐上我唱自己的歌","text":"我唱自己的歌在布满车前草的道路上在灌木的集市上在雪松和白桦树的舞会上在那山野的原始欢乐上我唱自己的歌我唱自己的歌在热电厂恐怖的烟云中在变速箱复杂的组织中在砂轮的亲吻中在那社会文明的运行中我唱自己的歌 我唱自己的歌即不陌生又不熟练我是练习曲的孩子愿意加入所有歌队为了不让规范的人们知道我唱自己的歌 我唱歌，唱自己的歌直到世界恢复了史前的寂寞细长的月亮从海边向我走来轻轻地问：为什么？你唱自己的歌 ——顾城 在满是荆棘的历程中，我可能被泡沫掩埋，请让我还来得及向世界挑战。 插入图的两种方法： 内链（空间）： 外链（图床）：","categories":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/tags/life/"}]},{"title":"【machine learning】linear regression        ","slug":"machinelearning-linear-regression","date":"2015-01-18T11:43:00.000Z","updated":"2016-07-16T06:35:11.702Z","comments":true,"path":"2015/01/18/machinelearning-linear-regression/","link":"","permalink":"https://scutccnl.github.io/2015/01/18/machinelearning-linear-regression/","excerpt":"一、曲线拟合 1、问题引入 ①假设现在有一份关于某城市的住房面积与相应房价的数据集","text":"一、曲线拟合 1、问题引入 ①假设现在有一份关于某城市的住房面积与相应房价的数据集 表1 居住面积与房价关系 图1 居住面积与房价关系 那么给定这样一个数据集，我们怎么学习出一个以住房面积大小为自变量的用于预测该城市房价的函数？ 问题可形式化为给定大小为m的训练样本集 我们希望学习的目标函数为 房价预测本质上是回归问题 a、回归分析挖掘自变量与因变量之间的关系 b、有监督的学习问题，所有的样本点都带有目标变量 c、输出变量为连续值，可取任意实数 ②假设现在我们有份更详尽的数据集，它还记录了卧室的数量 输入，X=(x1,x2) 假设每个自变量都与因变量Y存在线性相关 目标是学习出假设函数 2、怎样建模 ①基本概念 Relationshipl Linear correlated?l Nonlinear correlated?Mining relationl Correlation coefficient = 1时，称X,Y完全相关，X,Y之间具有线性函数关系 Special Casee.g. 猜想Y与X存在指数关系，观察lnY与X的线性相关性 General—Polynomial Curve Fit（多项式曲线拟合）找到合适的阶数k，使等式成立，譬如logistic regression。 ②多元变量线性回归 上文提到假设函数： 参数或权重(反映每个自变量对输出的影响)，使线性函数空间参数化(h形式已知,用参数来刻画)为了表示方便，令x0(对应截距项)，则上式可写成 注：k与自变量的个数有关，此处k=2 3、怎样获取参数合理的选择策略:对于该数据集的每一个样本，选定的参数使得尽可能接近y。在实际中，尽可能接近用代价函数来表示。Cost Function(代价函数)描述预测值与真实值之间的差距，从而优化目标函数参数，可以利用0-1损失，绝对值损失，平方损失，对数损失。对于线性回归问题，我们采用的目标函数为 这是普通最小二乘回归模型(statistics)，可以利用概率论知识解释为什么可以，如下。 二、概率解释1、选择最小二乘(平方损失)代价函数的理由：我们做出如下假设： E(i)：误差项(没有model出的效应，e.g.遗漏了某些因素的影响)或随机噪声进一步假设： 即 注意，下面式子与这条式子等价。 等价于 之后我们就可以利用似然函数解释最小二乘代价函数： 定义:给定随机变量X与参数，我们观察到结果Y的可能性 由E(i)之间的独立性假设，得 简单解释一下，我们的目标，是实现在给定的情况下，对于m个样本的输入，能输出的m个y的概率的总乘积最大，那构建的模型就越准确了，即最大似然估计。 定义：最大似然估计(maximum likelihood estimation) 当给定似然函数(关联y与x的概率模型)时，一种合理的参数估计方法是尽可 能选择使数据出现的概率最大，即最大化似然函数。 实际上，常用的是对数似然： 因而，最大似然估计等价于最小化平方损失函数，得证。 三、模型求解 1、梯度下降法 (steepest??gradient??descent) 负梯度方向是函数值下降的方向，利用负梯度方向来决定每次迭代的新的搜索方向，使得每次迭代能使待优化的目标函数逐步减小。 a：学习率 其中（关键）： LMS 更新法则： 注意：每次参数更新只用到一个训练样本，样本维数等于维数。 2、批量梯度下降(batch gradient descent) 每次参数更新，需要依赖训练集的所有样本。 对于线性回归问题，代价函数是凸二次规划函数，有全局最优解 图1 梯度下降法迭代过程 3、随机梯度下降 特点:1.每次随机选取一个样本点 立即更新参数2.单个样本点的代价函数值下降近似于总体的代价函数值下降3.对步长选择敏感 可能会出现overshoot the minimum 3、方法比较 1．梯度下降法是批量更新算法，随机梯度是在线算法 2．梯度法优化的是经验风险，随机梯度法优化的是泛化风险 3．梯度法可能陷入局部最优，随机梯度可能找到全局最优 4．梯度法对步长不敏感，随机梯度对步长选择敏感 5．梯度法对初始点(参数)选择敏感 4、输入预处理 a.归一化 输入特征归一化，确保特征在相似的尺度里，但不一定所有的数据都需要归一化。 理由：梯度下降法可能会存执之字形地下降，影响算法的收敛速度。 一般做法： 其中均值，最大值与最小值之差或标准差。 b.步长的选择 对于梯度下降法： 注意两个问题： 1、“调试”：如何确保梯度下降算法正确的执行； 2、如何选择正确的步长(learning rate): α 如何选择α-经验的方法：…, 0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1… 特别对于随机梯度下降法，步长的选择需满足两点：①保证算法收敛性②保证有机会搜索到全局最优解 5、正规方程假设函数作用于每个样本： 则： 代价函数可改成： 此问题等价于： 即两个向量之间的欧氏距离： 几何意义： 需保证可逆(可逆的充分条件:矩阵X各列线性无关) 回顾一下，上面我们的方法是利用迭代的方式求出，从而使代价函数值最小，并没有求出代价函数。也就是说，所谓的最优解能否求得，不管是通过迭代的方式或是其它方式也好，符合上面的条件才行。 但现实中的数据不是那么理想的。若不可逆，如何求解？1、求伪逆(statistics的解决方案)2、去掉冗余的特征（线性相关）3、去掉过多的特征，例如m &lt;= n (m为样本数, n为特征数) 四、小结1、梯度下降法需要选择合适的learning rate α;需要很多轮迭代即使n很大的时候效果也很好（n为特征数，即维度）2、正规方程不需要选择α不需要迭代，一次搞定 需要计算，其时间复杂度是 n很大，就非常慢，可以考虑降维","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://scutccnl.github.io/categories/Machine-Learning/"}],"tags":[{"name":"ML foundation","slug":"ML-foundation","permalink":"https://scutccnl.github.io/tags/ML-foundation/"}]},{"title":"python进行文档抽取与解析的简单实现        ","slug":"python-analysis","date":"2015-01-18T05:36:00.000Z","updated":"2016-07-16T06:35:11.714Z","comments":true,"path":"2015/01/18/python-analysis/","link":"","permalink":"https://scutccnl.github.io/2015/01/18/python-analysis/","excerpt":"一、前文 之前被叫去做网络爬虫，爬取新浪新闻的url，标题，内容和评论，不过在需求上有点改变，主要是评论的间隔被要求有‘\\t’的分割，比如将 1234&lt;comment&gt;2014-12-10 18:53:20 1004400533 遗弃亲生骨肉猪狗不如，难道就不怕受到良心谴责？你能睡得安稳？2014-12-10 17:17:07 3294923134 这父亲是人吗？&lt;/comment&gt;","text":"一、前文 之前被叫去做网络爬虫，爬取新浪新闻的url，标题，内容和评论，不过在需求上有点改变，主要是评论的间隔被要求有‘\\t’的分割，比如将 1234&lt;comment&gt;2014-12-10 18:53:20 1004400533 遗弃亲生骨肉猪狗不如，难道就不怕受到良心谴责？你能睡得安稳？2014-12-10 17:17:07 3294923134 这父亲是人吗？&lt;/comment&gt; 改为123456&lt;comment&gt;2014-12-10 18:53:20 1004400533遗弃亲生骨肉猪狗不如，难道就不怕受到良心谴责？你能睡得安稳？2014-12-10 17:17:07 3294923134这父亲是人吗？&lt;/comment&gt; 试过重新爬取，不过新浪在2015年后，做了些改变，一是评论api下的内容有了些修改，从原本的中文字符变为了’\\u’，解决办法可以参考另一篇博文 三张图告诉你python爬虫时转换\\u中文字符的“坑”，二是在爬虫上需要做好浏览器模拟的工作，不然很容易被封杀，而且，在做大规模爬取的时候，需要利用多线程或者分布式的手段进行，多线程稍不注意，到了系统线程的上限，这是要注意的。 二、抽取和解析 因为我想爬取这个页面（social）一年的内容，已经超过2万了（只算那些有评论的新闻），所以经常第二天回来发现中途error。分布式计算的东西现在还没去学习，所以还是复习一下python。 在这个简短的程序中，用到了SGMLParser类进行解析，这个类封装了可以实现对具有标签的字符串的处理函数，当然没有标签也是可以用的，不需要冠以html文本种类的要求，网上很多例子可能会拿HTMLParser与SGMLParser进行说明，通过解析X.html进行说明。这里我只采用单线程的方法。 SGMLParser: 1、通过利用开关变量的方法进行标签间内容的抽取和解析，在此之前，需要进行变量的初始化，可以利用init()或者reset()，一般用reset()。 2、start_x(),end_x(),handle_data()，这三个函数，第一个是当读取到;时，执行的函数，第一个是当读取到;时，执行的函数,第三个是当遇到标签内的内容，就会调用这个函数，更详细一点可以参考 这篇博文 变量说明： rootdir：原始文件目录 rootdir2：需要存放转换好的文件目录 方法说明： 1、通过SGMLParser读取;;中的内容，调用solve()函数，利用正则匹配的方法将原来不符合规范的空格替换为’\\t’，返回需要替换的内容到comment变量 2、利用正则匹配找到定位到;;，替换为Parse类对象的comment值 （正则表达式的方法参考以下注释） 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env python# -*- coding: utf-8 -*-from sgmllib import SGMLParserimport re,osrootdir = 'F:\\\\Python27\\\\pythonproject\\\\fuck\\\\file1\\\\'rootdir2 = 'F:\\\\Python27\\\\pythonproject\\\\fuck\\\\file2\\\\'class Parse(SGMLParser): def __init__(self,filename): self.filename = filename self.comment = '' SGMLParser.__init__(self) def reset(self): self.found_comment = False SGMLParser.reset(self) def start_comment(self, attrs): self.found_comment = True def end_comment(self): self.found_comment = False def handle_data(self, text): if self.found_comment == True: self.comment=solve(self.filename,text)def solve(filename,text): #找到3个或3个以上空格的地方，替换为'\\t' strinfo = re.compile('(\\s\\s\\s*)') str_result = strinfo.sub('\\t',text) return str_result if __name__ == '__main__': global rootdir,rootdir2 for parent,dirnames,filenames in os.walk(rootdir): #三个参数：分别返回1.父目录 2.所有文件夹名字（不含路径） 3.所有文件名字 for filename in filenames: #print filename filesource = open(rootdir+filename, 'a+') s = filesource.read() filesource.close() #初始化实例p,feed()函数为添加处理字符串 p = Parse(filename) p.feed(s) filedes = open(rootdir2+filename, 'a+') #因为原来原数据中存在不以&lt;/comment&gt;;结尾的内容，因此需要先做处理 pattern1='&lt;/comment&gt;;' if re.findall(pattern1,s) == []: s=s+'\\n&lt;/comment&gt;;' &lt;span style=\"white-space:pre\"&gt;; &lt;/span&gt;; #定位到comment标签位置，([\\s\\S]*)能够匹配所有字符，包括换行符，然后替换 strinfo = re.compile('&lt;comment&gt;;([\\s\\S]*)&lt;/comment&gt;;') str_result = strinfo.sub('&lt;comment&gt;;'+p.comment+'&lt;/comment&gt;;',s) filedes.write(str_result) filedes.close() 结果： 注意：win7系统一般文件夹下的文件总数（包括文件夹）不能超过21845个，不然会提示错误。","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[{"name":"spider","slug":"spider","permalink":"https://scutccnl.github.io/tags/spider/"}]},{"title":"【python web学习】python web窥探        ","slug":"python-web","date":"2015-01-15T07:51:00.000Z","updated":"2016-07-16T06:35:11.718Z","comments":true,"path":"2015/01/15/python-web/","link":"","permalink":"https://scutccnl.github.io/2015/01/15/python-web/","excerpt":"本文为参考网上一些博客翻译以及想法，自己写的一篇总结博文，可能有重复的地方，纯粹总结只用。阅读之前可参考: 1、How to write a web framework in Python（作者anandology是","text":"本文为参考网上一些博客翻译以及想法，自己写的一篇总结博文，可能有重复的地方，纯粹总结只用。阅读之前可参考: 1、How to write a web framework in Python（作者anandology是web.py代码的两位维护者之一，另一位则是大名鼎鼎却英年早逝的AaronSwartz ） 2、Why so many Python web frameworks? 也是一篇很好的文章，也许它会让您对Python中Web框架的敬畏之心荡然 无存:-) 如果你打算用python进行网络开发的话，自己写的框架可以说是一种不受支持的想法，可能使用一个现成的Web框架（如Djang、Tornado 、web.py 、Pylons等）会是更合适的选择，毕竟都是大师级的作品。 一、一次最简单的web之旅1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"myweb.py\"\"\"from wsgiref.simple_server import make_server, demo_apphttpd = make_server('', 8086, demo_app)sa = httpd.socket.getsockname()print 'http://&#123;0&#125;:&#123;1&#125;/'.format(*sa)# Respond to requests until process is killedhttpd.serve_forever() 在命令运行之后 打开浏览器：http://0.0.0.0:8086/ 一行”Hello world!” 和 众多环境变量值。 定位到simple_server.py文件，我们看到make_server函数和WSGIServer类 1234567891011121314151617181920212223242526272829303132333435 def make_server( host, port, app, server_class=WSGIServer, handler_class=WSGIRequestHandler): \"\"\"Create a new WSGI server listening on `host` and `port` for `app`\"\"\" server = server_class((host, port), handler_class) server.set_app(app) return serverclass WSGIServer(HTTPServer): \"\"\"BaseHTTPServer that implements the Python WSGI protocol\"\"\" application = None def server_bind(self): \"\"\"Override server_bind to store the server name.\"\"\" HTTPServer.server_bind(self) self.setup_environ() def setup_environ(self): # Set up base environment env = self.base_environ = &#123;&#125; env['SERVER_NAME'] = self.server_name env['GATEWAY_INTERFACE'] = 'CGI/1.1' env['SERVER_PORT'] = str(self.server_port) env['REMOTE_HOST']='' env['CONTENT_LENGTH']='' env['SCRIPT_NAME'] = '' def get_app(self): return self.application def set_app(self,application): self.application = application 可以看到，我们运行python文件后启动的是WSGIServer类对象（继承于HTTPServer，子类有run函数，后文会详细讲一下），而demo_app是一个拥有特定格式:接受两个参数，一个列表return 对象的函数，抑或是类、类对象（见下文）。很多时候，要简单写一个web框架，主要需要改动传入的app以及server。 二、app的修改其中，可调用对象 包括 函数、方法、类 或者 具有call方法的 实例；environ 是一个字典对象，包括CGI风格的环境变量（CGI-style environment variables）和 WSGI必需的变 量（WSGI-required variables）；start_response 是一个可调用对象，它接受两个常规参数（status，response_headers）和 一个 默认参数（exc_info）；字符串迭代对象 可以是 字符 串列表、生成器函数 或者 具有iter方法的可迭代实例。更多细节参考Specification Details。 The Application/Framework Side中给出了一个典型的application实现： 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"def simple_app(environ, start_response): \"\"\"Simplest possible application object\"\"\" status = '200 OK' response_headers = [('Content-type', 'text/plain')] start_response(status, response_headers) return ['Hello world!\\n'] 替换原来自带的demo_app，重新运行之 123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"code.py\"\"\"from wsgiref.simple_server import make_serverfrom application import my_app as appif __name__ == '__main__': httpd = make_server('', 8086, app) sa = httpd.socket.getsockname() print 'http://&#123;0&#125;:&#123;1&#125;/'.format(*sa) #Respond to requests until process is killed httpd.serve_forever() 这时就输出hello world!而没有环境变量。因为demo_app.py是这样的： 12345678910def demo_app(environ,start_response): from StringIO import StringIO stdout = StringIO() print &gt;;&gt;;stdout, \"Hello world!\" print &gt;;&gt;;stdout h = environ.items(); h.sort() for k,v in h: print &gt;;&gt;;stdout, k,'=', repr(v) start_response(\"200 OK\", [('Content-Type','text/plain')]) return [stdout.getvalue()] 三、URL调度修改之前的访问server都是基于host+port的形式，那要怎样实现url的分发呢。这需要对app进行修改才行。说到这里，就先将app从一个函数改为一个类吧，再做url区分处理。 123456789101112131415#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"class my_app: def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Hello world!\\n\" 复习一下python类的语法，说说为什么可以这样写。开始的app可以这样用 1list = simple_app(a,b) 现在也可以这样用 1list = my_app(a,b) 注：其中参数来自init()，返回值来自iter()的return值（yield返回的就是一个可迭代对象），也许你会问，如果是传类对象的话呢？且看下下文。 再在return的函数即iter()中修改根据不同的path进行不同返回。 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"class my_app: def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): path = self.environ['PATH_INFO'] #environ的作用看到了吧 if path == \"/\": return self.GET_index() elif path == \"/hello\": return self.GET_hello() else: return self.notfound() def GET_index(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Welcome!\\n\" def GET_hello(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Hello world!\\n\" def notfound(self): status = '404 Not Found' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Not Found\\n\" 这时用浏览器就可以访问/,/hello,其他访问为Not Found。 四、重构1、正则匹配URL消除URL硬编码，增加URL调度的灵活性： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"import re ##########修改点class my_app: urls = ( (\"/\", \"index\"), (\"/hello/(.*)\", \"hello\"), ) ##########修改点，Django工程中url.py即视感 def __init__(self, environ, start_response): self.environ = environ self.start = start_response def __iter__(self): ##########修改点 path = self.environ['PATH_INFO'] method = self.environ['REQUEST_METHOD'] for pattern, name in self.urls: m = re.match('^' + pattern + '$', path) #注意这里，url匹配函数名 if m: #pass the matched groups as arguments to the function args = m.groups() funcname = method.upper() + '_' + name if hasattr(self, funcname): func = getattr(self, funcname) return func(*args) return self.notfound() def GET_index(self): status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) #遵循调用start_response后再return iterObject yield \"Welcome!\\n\" def GET_hello(self, name): ##########修改点 status = '200 OK' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Hello %s!\\n\" % name def notfound(self): status = '404 Not Found' response_headers = [('Content-type', 'text/plain')] self.start(status, response_headers) yield \"Not Found\\n\"``` ## 2、消除GET_*方法中的重复代码，并且允许它们返回字符串： ```python #!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"import reclass my_app: urls = ( (\"/\", \"index\"), (\"/hello/(.*)\", \"hello\"), ) def __init__(self, environ, start_response): ##########修改点 self.environ = environ self.start = start_response self.status = '200 OK' self._headers = [] def __iter__(self): ##########修改点 result = self.delegate() #利用这个函数先进行返回结果的收集 self.start(self.status, self._headers) #start_response # 将返回值result（字符串 或者 字符串列表）转换为迭代对象 if isinstance(result, basestring): return iter([result]) else: return iter(result) def delegate(self): ##########修改点 path = self.environ['PATH_INFO'] method = self.environ['REQUEST_METHOD'] for pattern, name in self.urls: m = re.match('^' + pattern + '$', path) if m: # pass the matched groups as arguments to the function args = m.groups() funcname = method.upper() + '_' + name if hasattr(self, funcname): func = getattr(self, funcname) return func(*args) return self.notfound() def header(self, name, value): ##########修改点 self._headers.append((name, value)) def GET_index(self): ##########修改点 self.header('Content-type', 'text/plain') return \"Welcome!\\n\" def GET_hello(self, name): ##########修改点 self.header('Content-type', 'text/plain') return \"Hello %s!\\n\" % name def notfound(self): ##########修改点 self.status = '404 Not Found' self.header('Content-type', 'text/plain') return \"Not Found\\n\" 3、抽象出框架为了将类my_app抽象成一个独立的框架，需要作出以下修改： 1、剥离出其中的具体处理细节：urls配置 和 GET_*方法（改成在多个类中实现相应的GET方法） 2、把方法header实现为类方法（classmethod），以方便外部作为功能函数调用 3、改用 具有call方法的 实例 来实现application（上文提到） 修改后的application.py（最终版本）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- coding: utf-8 -*-\"\"\"application.py\"\"\"import reclass my_app: \"\"\"my simple web framework\"\"\" headers = [] def __init__(self, urls=(), fvars=&#123;&#125;): self._urls = urls self._fvars = fvars def __call__(self, environ, start_response): self._status = '200 OK' # 默认状态OK del self.headers[:] # 清空上一次的headers result = self._delegate(environ) start_response(self._status, self.headers) # 将返回值result（字符串 或者 字符串列表）转换为迭代对象 if isinstance(result, basestring): return iter([result]) else: return iter(result) def _delegate(self, environ): path = environ['PATH_INFO'] method = environ['REQUEST_METHOD'] for pattern, name in self._urls: m = re.match('^' + pattern + '$', path) if m: # pass the matched groups as arguments to the function args = m.groups() funcname = method.upper() # 方法名大写（如GET、POST） klass = self._fvars.get(name) # 根据字符串名称查找类对象 if hasattr(klass, funcname): func = getattr(klass, funcname) return func(klass(), *args) return self._notfound() def _notfound(self): self._status = '404 Not Found' self.header('Content-type', 'text/plain') return \"Not Found\\n\" @classmethod def header(cls, name, value): cls.headers.append((name, value)) 到这里，基本上就算是小功告成了，但只是了解了怎么用那些子类，大篇幅还是讲怎么设计。窥探一下wsgiref.simple_server。 五、wsgiref原理介绍1、概述a.什么是WSGI, WSGI application, WSGI server, WSGI middleware. WSGI是关于Python脚本与Web服务器交互的协议，wsgi将 web 组件分为三类： web服务器,web中间件,web应用程序。 b.WSGI Server有哪些 比如 Django、CherryPy 都自带 WSGI server,主要是测试用途, 发布时则使用生产环境的 WSGI server，例如Apache，nginx等，而有些 WSGI 下的框架比如 pylons、bfg 等, 自己不实现 WSGI server。 wsgiref就是python自带的WSGI server。上面提到的app需要传入的两个参数application(environ, start_response)，其实就是一个接口两个参数的集合体。一篇博文这样说明： wsgi server 基本工作流程： 1、服务器创建socket，监听端口，等待客户端连接。 2、当有请求来时，服务器解析客户端信息放到环境变量environ中，并调用绑定的handler来处理请求。 3、handler解析这个http请求，将请求信息例如method，path等放到environ中。 4、wsgi handler再将一些服务器端信息也放到environ中，最后服务器信息，客户端信息，本次请求信息全部都保存到了环境变量environ中。 5、wsgi handler 调用注册的wsgi app，并将environ和回调函数传给wsgi app 6、wsgi app 将reponse header/status/body 回传给wsgi handler 7、最终handler还是通过socket将response信息塞回给客户端。 2、组成（python2.7.8） simple_server 这一模块实现了一个简单的 HTTP 服务器，并给出了一个简单的 demo，运行： python simple_server.py 会启动这个demo，运行一次请求，并把这次请求中涉及到的环境变量在浏览器中显示出来。 handlers simple_server模块将HTTP服务器分成了 Server 部分和Handler部分，前者负责接收请求，后者负责具体的处理， 其中Handler部分主要在handlers中实现。 headers 这一模块主要是为HTTP协议中header部分建立数据结构。 util 这一模块包含了一些工具函数，主要用于对环境变量，URL的处理。 validate 这一模块提供了一个验证工具，可以用于验证你的实现是否符合WSGI标准。 simple_server 模块主要有两部分内容，上面一到四的内容可以总结。 应用程序 函数demo_app是应用程序部分 服务器程序 服务器程序主要分成Server 和 Handler两部分，另外还有一个函数 make_server 用来生成一个服务器实例 各种继承关系： 12345678910111213141516171819# M:# +------------+# | BaseServer |# +------------+# |# V# +------------+# | TCPServer |# +------------+# |# V# +------------+# | HTTPServer |# +------------+# |# V# +------------+# | WSGIServer |# +------------+ 12345678910111213141516171819 # M:# +--------------------+# | BaseRequestHandler |# +--------------------+# |# V# +-----------------------+# | StreamRequestHandler |# +-----------------------+# |# V# +------------------------+# | BaseHTTPRequestHandler |# +------------------------+# |# V# +--------------------+# | WSGIRequestHandler |# +--------------------+ # M: # +-------------+ # | BaseHandler | # +-------------+ # | # V # +----------------+ # | SimpleHandler | # +----------------+ # | # V # +---------------+ # | ServerHandler | # +---------------+ 在调用make_server的时候，都发生了什么 再这里，就不细讲handler的处理过程了，很多时候网络handler的研究需要看源码才能真正消化。 以下完全引用on_1y的一篇博文，该博文讲得很细，不过需要研究源码才能真正消化。可以先看doc:https://docs.python.org/2/library/wsgiref.html再看源码:https://pypi.python.org/pypi/wsgiref headers 这个模块是对HTTP 响应部分的头部设立的数据结构，实现了一个类似Python 中 dict的数据结构。可以看出，它实现了一些函数来支持一些运算符，例如 len, setitem, getitem, delitem, str, 另外，还实现了 dict 操作中的get, keys, values函数 util 这个模块主要就是一些有用的函数，用于处理URL, 环境变量。 validate 这个模块主要是检查你对WSGI的实现，是否满足标准，包含三个部分： validator Wrapper Check validator 调用后面两个部分来完成验证工作，可以看出Check部分对WSGI中规定的各个部分进行了检查。","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[{"name":"python web","slug":"python-web","permalink":"https://scutccnl.github.io/tags/python-web/"}]},{"title":"python spider error occurs to Chinese words","slug":"python-chinese","date":"2015-01-09T11:51:00.000Z","updated":"2016-07-16T06:35:11.714Z","comments":true,"path":"2015/01/09/python-chinese/","link":"","permalink":"https://scutccnl.github.io/2015/01/09/python-chinese/","excerpt":"平台为win7系统","text":"平台为win7系统 一劳永逸的方法： 1234567s=s.replace(\"'\",'\"')s=s.replace(\"\\n\",'')s1=\"u'\"+s+\"'\"try: ss=eval(s1) except: return 将’转换为“，将\\n去掉。利用eval转化即可。","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/tags/python/"}]},{"title":"今天真是窘迫的一天","slug":"poor-day","date":"2014-12-28T12:23:50.000Z","updated":"2016-07-16T06:35:11.710Z","comments":true,"path":"2014/12/28/poor-day/","link":"","permalink":"https://scutccnl.github.io/2014/12/28/poor-day/","excerpt":"今天是一个窘迫的一天，昨天上午去实验室，发现前天跑的爬虫还是没爬完，郁闷，有的爬的数据比它多用几个小时就跑完了，然后又开了一个cmd窗口继续跑另一个爬虫，后来司机，鼠标也动不了，强制关机后不进行硬盘检查（在笔记本经常这样做，省时），不过在台式机还是第一次这么干。今天终于尝到苦头。","text":"今天是一个窘迫的一天，昨天上午去实验室，发现前天跑的爬虫还是没爬完，郁闷，有的爬的数据比它多用几个小时就跑完了，然后又开了一个cmd窗口继续跑另一个爬虫，后来司机，鼠标也动不了，强制关机后不进行硬盘检查（在笔记本经常这样做，省时），不过在台式机还是第一次这么干。今天终于尝到苦头。 今天依旧跑的是昨天强制关机后的那个程序（注意特指），不过下午才到的实验室，居然比昨天还慢，一半都没有。索性不理它，继续搞，再开窗口，到了四点多的时候，厄运来了，自动关机。自动重启，硬盘检查，不过启动失败直接进入系统修复，失败。想到的是四种方法，系统修复，安全模式，pe系统的修复，重装系统，后来真的只能重装系统了，pe系统修复那步也许做得不太好，不过以防万一，就将c盘中的虚拟机拷到f盘。 也许是我频繁得对硬盘io进行操作，导致D盘受损，开始以为是系统问题，想继续做个系统，边做边上网搜方法，用了一下diskGenius，但最终还是得将d盘格式化，毕竟里面的东西我只放了个Dreamweaver而已，大不了再下一个。 看上去好像都搞定了的样子，其实最重要的事情能不能成功都是还是挺担心的，虽说备份了虚拟机在c盘的东西，不过还是第一次要想这么做。尼玛看来我没有好好调研清楚怎么迁移virtualbox的系统就开始弄，确实有点草率，映射的硬盘我都不记得在哪里，拷过来的东西只有几兆，显然错了。近乎崩溃……工程还没有完全拷过来（这已经够崩溃了） 后来逐渐深入才知道，要重新搭一个环境也是挺久的，django,mongodb以及webvirtmgr附带的东西，数据库记得当时调试的时候是手打出来的假数据，现在不知新建一个空的会不会报错。 明天又是一个挑战的一天，挺浪费时间的，又得搭环境，又得写服务器信息栏目后台，还好前端一直在win7下写的，之前后天边调编写用了接近3天，希望在之前的经验下，能在明天内既搭好环境又一气呵成写好后台，老天保佑，我不想做太多无谓时间牺牲，虽说反驳者觉得可以练练手，写重复的东西你说呢！？","categories":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/categories/life/"}],"tags":[{"name":"实验室","slug":"实验室","permalink":"https://scutccnl.github.io/tags/实验室/"},{"name":"spider","slug":"spider","permalink":"https://scutccnl.github.io/tags/spider/"}]},{"title":"考研日","slug":"postgraduate-exam","date":"2014-12-27T12:45:09.000Z","updated":"2016-07-16T06:35:11.710Z","comments":true,"path":"2014/12/27/postgraduate-exam/","link":"","permalink":"https://scutccnl.github.io/2014/12/27/postgraduate-exam/","excerpt":"微信发一条真诚祝福，也是对自己的祝福勉励，不忘自己是怎么走到这一步，运气背，但也阴差阳错。 今天是考研的第一天，曾经很担心这一天的到来，直到9月中旬。依稀记得，8月刚过20，内心甚是纠结，最后还是面对现实，做两手准备，虽是不甘，也无可奈何。","text":"微信发一条真诚祝福，也是对自己的祝福勉励，不忘自己是怎么走到这一步，运气背，但也阴差阳错。 今天是考研的第一天，曾经很担心这一天的到来，直到9月中旬。依稀记得，8月刚过20，内心甚是纠结，最后还是面对现实，做两手准备，虽是不甘，也无可奈何。 今天起得不算太晚，9点出头，不想去实验室，只想到图书馆坐坐，看看书，一到那里，人出奇得多，不过转念一想，考试月，理所当然，自从大四后关于自习室的念想都是研究生层面啊。 研究生阶段的方向，如无意外，无其它偏好，应该就是数据挖掘，喜好程度，中偏上而已。做做工程也好，搞搞理论也罢，出路两条，创业或工作，不止说说而已，咳咳。 慢慢接近自己想得到的，不忘初衷，成长当如此。","categories":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://scutccnl.github.io/tags/life/"}]},{"title":"html与javascript之网络篇","slug":"html-javascript-1","date":"2014-12-26T06:09:00.000Z","updated":"2016-07-16T06:35:11.698Z","comments":true,"path":"2014/12/26/html-javascript-1/","link":"","permalink":"https://scutccnl.github.io/2014/12/26/html-javascript-1/","excerpt":"此篇依然与前一篇动态篇环境一样，基于jquery #一、表单提交（post的同步加载） 12345678 &lt;form method=\"post\" onSubmit=\"return check_recover()\"&gt;; &lt;a href=\"javascript:void(0)\" id=\"allSelect2\" &gt;;全部&lt;/a&gt;; &lt;a &gt;;-&lt;/a&gt;; &lt;a href=\"javascript:void(0)\" id=\"noneSelect2\" &gt;;无&lt;/a&gt;; &lt;a &gt;;-&lt;/a&gt;; &lt;input type=\"submit\" class=\"btn btn-primary\" name=\"recover\" value=\"恢复所选\"&gt;;&lt;/input&gt;; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;;删除所选&lt;/button&gt;;&lt;/form&gt;;","text":"此篇依然与前一篇动态篇环境一样，基于jquery #一、表单提交（post的同步加载） 12345678 &lt;form method=\"post\" onSubmit=\"return check_recover()\"&gt;; &lt;a href=\"javascript:void(0)\" id=\"allSelect2\" &gt;;全部&lt;/a&gt;; &lt;a &gt;;-&lt;/a&gt;; &lt;a href=\"javascript:void(0)\" id=\"noneSelect2\" &gt;;无&lt;/a&gt;; &lt;a &gt;;-&lt;/a&gt;; &lt;input type=\"submit\" class=\"btn btn-primary\" name=\"recover\" value=\"恢复所选\"&gt;;&lt;/input&gt;; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;;删除所选&lt;/button&gt;;&lt;/form&gt;; 解释：当点击submit对应的按钮时，会直接提交到服务器，当此前为调用check_recover()函数，在这个函数中可以判断提交的内容是否合法，如果是则return true，则完成表单提交，实现同步加载。 二、ajax异步加载123456789101112131415function post_message1()&#123;//alert('success')data=&#123;'type':\"2\",'ip':'127.0.0.1'&#125;;$.post($(this).attr('action'), data, function(data,status,xhr)&#123; if(status==\"success\")&#123;change();&#125;&#125;);&#125; function post_message2()&#123;$.getJSON(\"yoururl\",function(data)&#123;dosomething();&#125;);&#125; 解释： 1.当调用post_message()函数时，发送data数据到服务器，当成功返回时，再调用change()函数。 2.当调用post_message()函数时，访问url为yoururl的链接，返回含有data数据的response，然后调用dosomething()函数。 三、刷新当前页面1window.location.reload(); 四、定时执行某些特定操作，譬如更新图 123 function () &#123; window.setInterval('hostusage()', 2000);&#125; 解释：两秒调用hostusage()函数一次","categories":[{"name":"前端","slug":"前端","permalink":"https://scutccnl.github.io/categories/前端/"}],"tags":[{"name":"js func","slug":"js-func","permalink":"https://scutccnl.github.io/tags/js-func/"}]},{"title":"html与javascript之动态篇        ","slug":"html-javascript-2","date":"2014-12-26T05:26:00.000Z","updated":"2016-07-16T06:35:11.698Z","comments":true,"path":"2014/12/26/html-javascript-2/","link":"","permalink":"https://scutccnl.github.io/2014/12/26/html-javascript-2/","excerpt":"以下所讲内容采用bootstrap模板，jquery库，对于原生html大致也同样适用 一、侧边栏分页","text":"以下所讲内容采用bootstrap模板，jquery库，对于原生html大致也同样适用 一、侧边栏分页 12345678910111213141516171819202122232425262728293031323334353637 &lt;div class=\"navbar-default sidebar\" role=\"navigation\"&gt; &lt;div class=\"sidebar-nav navbar-collapse\"&gt; &lt;ul class=\"nav\" id=\"side-menu\"&gt; &lt;li class=\"sidebar-search\"&gt; &lt;div class=\"input-group custom-search-form\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search...\"&gt; &lt;span class=\"input-group-btn\"&gt; &lt;button class=\"btn btn-default\" type=\"button\"&gt; &lt;i class=\"fa fa-search\"&gt;&lt;/i&gt; &lt;/button&gt; &lt;/span&gt; &lt;/div&gt; &lt;!-- /input-group --&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;&lt;i class=\"fa fa-wrench fa-fw\"&gt;&lt;/i&gt; 审核业务&lt;span class=\"fa arrow\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"nav nav-second-level\"&gt; &lt;li&gt; &lt;a href=\"&#123;% url 'user-review' %&#125;\"&gt;用户审核业务&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"&#123;% url 'device-review' %&#125;\"&gt;设备审核业务&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"&#123;% url 'middleware-review' %&#125;\"&gt;中间件审核业务&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- /.nav-second-level --&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- /.sidebar-collapse --&gt;&lt;/div&gt;&lt;!-- /.navbar-static-side --&gt; 当点击某一项跳转到另外页面时，可以在相应的html页面中改为 123456789101112131415 &lt;li class=\"active\"&gt; &lt;a href=\"#\"&gt;&lt;i class=\"fa fa-wrench fa-fw\"&gt;&lt;/i&gt; 审核业务&lt;span class=\"fa arrow\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"nav nav-second-level\"&gt; &lt;li&gt; &lt;a class=\"active\" href=\"&#123;% url 'user-review' %&#125;\"&gt;用户审核业务&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"&#123;% url 'device-review' %&#125;\"&gt;设备审核业务&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"&#123;% url 'middleware-review' %&#125;\"&gt;中间件审核业务&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- /.nav-second-level --&gt;&lt;/li&gt; 二、单击按钮弹出modal对话框 1&lt;button type=\"button\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#myModal\"&gt;新增用户&lt;/button&gt; modal为嵌入在html div中的html隐藏文本 123456789101112131415161718192021222324252627&lt;div aria-hidden=\"true\" aria-labelledby=\"myModalLabel\" class=\"modal fade\" id=\"myModal\" role=\"dialog\" tabindex=\"-1\"&gt;&lt;div class=\"modal-dialog\"&gt;&lt;div class=\"modal-content\"&gt;&lt;div class=\"modal-header\" style=\"background:#d9edf7\"&gt;&lt;button aria-hidden=\"true\" class=\"close\" data-dismiss=\"modal\" type=\"button\"&gt;×&lt;/button&gt;&lt;h4 class=\"modal-title\" id=\"myModalLabel\"&gt;新增用户信息&lt;/h4&gt;&lt;/div&gt; &lt;div class=\"modal-body form-horizontal\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"username\" class=\"col-sm-2 control-label\"&gt;用户名&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"text\" class=\"form-control\" id=\"username\" placeholder=\"用户名\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;input type=\"hidden\" name=\"add-name\" id=\"add-id\"&gt;&lt;/input&gt; &lt;button class=\"btn btn-default\" data-dismiss=\"modal\" type=\"button\"&gt;关闭&lt;/button&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" name=\"addButton\" value=\"确定\"&gt;&lt;/input&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 三、按钮触发事件 12345678910 &lt;input type=\"submit\" class=\"btn btn-primary\" name=\"pass\" value=\"通过所选\"&gt;&lt;/input&gt; &lt;script type=\"text/javascript\"&gt;$(document).ready(function()&#123;$(\"input[name='pass']\").click(function()&#123;check(\"hidden-value2\")&#125;)&#125;) &lt;/script&gt; 监听name为pass的按钮点击事件，当成也可以在button中添加onclick方法。 四、获取table的行列的文本内容，或是值 1var rowsize = document.getElementById('user-history-body').getElementsByTagName('tr').length 解释：获取tbody—，得到其下tr标签的个数。 1var td = document .getElementById (\"dataTables-user-history\").rows [i+1].cells[8].innerHTML 解释：获取 1&lt;table class=\"table table-striped table-bordered table-hover\" id=\"dataTables-user-history\"&gt; 下tobody的第i+1行第8列的文本 五、checkbox的全选和全不选操作 假设监听的对象的id=”chk_all2”，另外需置所有的checkbox的name=”transPro2” 1234567891011 //&lt;!--全选与全不选的操作（点击checkbox）--&gt;$(document).on(\"click\",\"#chk_all2\",function()&#123; var ischecked= $(\"#chk_all2:checked\").length var $checkboxs =$(\"input[name='transPro2']\") if(ischecked)&#123; $checkboxs.prop(\"checked\",true) &#125;else&#123; $checkboxs.prop(\"checked\",false) &#125;&#125;)//&lt;!--end--&gt; 1.可以类似QQ邮箱那样用checkbox控制checkbox 12345&lt;input type=\"checkbox\" name=\"transPro2\" id=\"chk_all2\"/&gt;2.用点击文本的方式控制则为:```html&lt;a href=\"javascript:void(0)\" id=\"allSelect2\" &gt;全部&lt;/a&gt; 而javascript改为 1234567 &lt;script type=\"text/javascript\"&gt;$(document).on(\"click\",\"#allSelect2\",function()&#123;var $checkboxs =$(\"input[name='transPro2']\")$checkboxs.prop(\"checked\",true)&#125;) &lt;/script&gt; 注意有些人喜欢将 1href=\"javascript:void(0)\" 改为href=”#”，但这样的话点击之后会使页面回到页首部，太过突兀。","categories":[{"name":"前端","slug":"前端","permalink":"https://scutccnl.github.io/categories/前端/"}],"tags":[{"name":"js func","slug":"js-func","permalink":"https://scutccnl.github.io/tags/js-func/"}]},{"title":"冲茶之道","slug":"drink-tea","date":"2014-12-13T09:02:00.000Z","updated":"2016-07-16T06:35:11.694Z","comments":true,"path":"2014/12/13/drink-tea/","link":"","permalink":"https://scutccnl.github.io/2014/12/13/drink-tea/","excerpt":"沏茶的艺术 1.白鹤沐浴 （洗 杯）：用开水洗净茶具 2.乌龙入宫 （落 茶）：把铁观音茶放入茶具，放茶量约占茶具容量的五分；","text":"沏茶的艺术 1.白鹤沐浴 （洗 杯）：用开水洗净茶具 2.乌龙入宫 （落 茶）：把铁观音茶放入茶具，放茶量约占茶具容量的五分； 3.悬壶高冲 （冲 茶）：把滚开的水提高冲入茶壶或盖瓯，使茶叶转动； 4.春风拂面 （刮泡沫）：用壶盖或瓯盖轻轻刮去漂浮的白泡沫，使其清新洁净； 5.关公巡城 （倒茶）：把泡一，二分钟后的茶水依次巡回注入并列的茶杯里； 6.韩信点兵 （点 茶）：茶水倒到少许时要一点一点均匀地滴到各茶杯里； 7.鉴尝汤色 （看 茶）：观尝杯中茶水的颜色 8.品啜甘霖 （喝 茶）：乘热细缀，先闻其香，后尝其味，边啜边闻，浅斟细饮。饮量虽不多，但能齿颊留香，喉底回甘，心旷神怡，别有情趣。","categories":[{"name":"tea","slug":"tea","permalink":"https://scutccnl.github.io/categories/tea/"}],"tags":[{"name":"tea","slug":"tea","permalink":"https://scutccnl.github.io/tags/tea/"}]},{"title":"python2.x学习小记","slug":"python2.x-study","date":"2014-12-11T12:14:00.000Z","updated":"2016-07-16T06:35:11.714Z","comments":true,"path":"2014/12/11/python2.x-study/","link":"","permalink":"https://scutccnl.github.io/2014/12/11/python2.x-study/","excerpt":"不定时更新，不一定适合3.X，但一定适合2.7。一、Python中的装饰器","text":"不定时更新，不一定适合3.X，但一定适合2.7。一、Python中的装饰器 1234567891011121314151617def main(): def decorator_with_params(arg_of_decorator): print arg_of_decorator print '1' def newDecorator(func): print '3' print func.__name__ return func(1,2) print '2' return newDecorator @decorator_with_params(\"deco_args\") def foo(a,b): print 'foo('+str(a)+','+ str(b)+') is called'if __name__ == '__main__': main() 输出结果： deco_args 1 2 3 foo foo(1,2) is called","categories":[{"name":"python","slug":"python","permalink":"https://scutccnl.github.io/categories/python/"}],"tags":[{"name":"python foundation","slug":"python-foundation","permalink":"https://scutccnl.github.io/tags/python-foundation/"}]},{"title":"mongodb在python中的应用——利用pymongo和mongoengine        ","slug":"pymongo-vs-mongoengine","date":"2014-12-10T04:56:00.000Z","updated":"2016-07-16T06:35:11.710Z","comments":true,"path":"2014/12/10/pymongo-vs-mongoengine/","link":"","permalink":"https://scutccnl.github.io/2014/12/10/pymongo-vs-mongoengine/","excerpt":"一、前文Django 是一种 Python Web 框架，由对象关系映射器 (ORM)、后端控制器和模板系统组成。MongoDB 是一种面向文档的数据库（也称为 NoSQL 数据库），能有效地进行扩展并提供高性能。在本文中，我们将学习如何从 Python 调用 MongoDB（使用 MongoEngine），以及如何将它集成到 Django 项目中以代替内置的 ORM。","text":"一、前文Django 是一种 Python Web 框架，由对象关系映射器 (ORM)、后端控制器和模板系统组成。MongoDB 是一种面向文档的数据库（也称为 NoSQL 数据库），能有效地进行扩展并提供高性能。在本文中，我们将学习如何从 Python 调用 MongoDB（使用 MongoEngine），以及如何将它集成到 Django 项目中以代替内置的 ORM。NoSQL 数据库是 “下一代数据库，主要具有以下几个要点：非关系型、分布式、开放源码和可水平伸缩”。面向文档的数据库 MongoDB 就是这种类型的数据库。要添加对 MongoDB 的支持非常容易，但要以失去自动管理面板为代价。因此，您必须根据您的需要进行权衡。MongoDB 是一种无模式数据库，与关系型数据库完全相反。无模式数据库没有使用表格，而是使用由文档组成的集合。这些文档是使用对象字面量语法创建的。 图片不可见可直接看原文可参考： http://www.zhihu.com/question/20059632 http://www.csdn.net/article/2014-03-06/2818652-when-use-mongodb-rather-mysql 二、工程需求 Django 通过mongoengine库调用mongoDB，由于mongoengine底层使用的是pymongo库，所以安装mongoengine的时候一定要安装与其版本配套的pymongo版本。几条命令，分别用于安装pymongo,mongodb,关/开mongodb服务，若easy_install安装不成功，就要安装easy_install工具： 123456789101112131415easy_install pymongoapt-get install mongodbservice mongodb stop/start``` ### 第一部分：pymongo ```python import pymongo con=pymongo.Connection('127.0.0.1',27017) #连接到数据库 db=con.cimcc #获取数据库 db.authenticate('username','password') collection=db.cimcc_user #获得表 举例子应用： 1.查找 1collection.find(&#123;'level':2,'userid':int(float(item))&#125;) 返回list，下面2有示例 2.降序排序，获取键值 12for i in collection.find().sort([(\"userid\",-1)]): userid=i['userid']+userid 3.插入数据项 1collection.insert(&#123;'userid':1&#125;) 4.更新 1collection.update(&#123;'userid':int(float(item))&#125;,&#123;'$set':&#123;'status':1&#125;&#125;,upsert=False,multi=True) 有兴趣可以研究一下update的四个参数，第一个为匹配，第二个为条件（条件上可以大作文章），第三个为没找到是否插入，第四个为是否支持多操作 pymongo够直接，但脱离了python web设计的本意，django也是mvc设计的典型例子，然后利用pymongo就不能很好地体现这点，耦合度较高。 第二部分：mongoengine 其实开始我是打算用django-nonrel，因为利用其可以再内存中模拟ORM，继承models.Model,管理者admin就有一个可视化管理数据库的界面（自带），也可以利用Model的函数映射到mongodb，但想想就好，后来没能成功装上，估计被墙了。后来发现知乎有人说：django的ORM并不支持NoSQL，但是有一个叫django-nonrel的分支，扩展了django的ORM，支持部分NoSQL数据库，其中包括mongodb 从我最后一次关心django-nonrel时它的可用度来看，实际生产环境使用还是很困难。比如说： mongodb类NoSQL天然没有join操作，所以在django-nonrel中使用mongodb时没有多表继承功能，只能从abstract类继承 没有join的操作也意味着很多atomic的SQL查询需要转换成非atomic的nosql查询 很多原ORM的特性在django-nonrel中使用会抛出NotImplemented的异常。 所以正常情况下请勿使用django-nonrel提供的nosql支持（除非你有兴趣给它贡献代码） http://www.zhihu.com/question/19818326 于是我还是用了mongoengine，继承Document而不是models.Model，效果也还行。 123456789101112from mongoengine import *connect('database',host='127.0.0.1',username='username',password='password')# Create your models here.class cimc_message(Document): msg_from=StringField(required=True) to=IntField(required=True) msg_type=StringField(required=True) status=IntField(required=True) result=IntField(required=True) def insert(self): self.save() 1.get_or_create 1cimc_message.objects.get_or_create(msg_from='admin',to='xiaoming',msg_type='type1',status=0,defaults=msg_dic) 找到匹配条件就返回该条数据，否则就插入defaults，defaults为字典 2.delete 1cimc_message.objects(msg_from='admin',to='xiaoming',msg_type='type1',status=0).delete() 其他的举一反三，边用边找","categories":[{"name":"database","slug":"database","permalink":"https://scutccnl.github.io/categories/database/"}],"tags":[{"name":"pymongo","slug":"pymongo","permalink":"https://scutccnl.github.io/tags/pymongo/"},{"name":"mongoengine","slug":"mongoengine","permalink":"https://scutccnl.github.io/tags/mongoengine/"}]},{"title":"linux系统管理常用命令（不定时更新）        ","slug":"linux-management-command","date":"2014-12-09T13:51:00.000Z","updated":"2016-07-16T06:35:11.702Z","comments":true,"path":"2014/12/09/linux-management-command/","link":"","permalink":"https://scutccnl.github.io/2014/12/09/linux-management-command/","excerpt":"1、关闭apache版本一 1/etc/init.d/httpd stop","text":"1、关闭apache版本一 1/etc/init.d/httpd stop 版本二 1/etc/init.d/apache2 stop 2、查看80端口 1netstat -anp |grep 80 参数说明： -p process -a all -n 以数字显示地址和端口（否则忽略虚拟机动态ip，127.0.0.1会以localhost显示） 3、进程相关 ps 使用权限：所有使用者 使用方式： ps [options] [–help] 说明：显示瞬间行程(process)的动态 参数： ps的参数非常多,在此仅列出几个常用的参数并大略介绍含义 -A 列出所有的进程 -w 显示加宽可以显示较多的资讯 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 可添加 |grep xx 过滤用户 杀死进程： kill -s 9 xxx(pid)","categories":[{"name":"linux","slug":"linux","permalink":"https://scutccnl.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://scutccnl.github.io/tags/linux/"}]},{"title":"linux命令操作学习（摘自鸟哥私房菜基础篇）        ","slug":"linux-common-command","date":"2014-11-24T11:37:00.000Z","updated":"2016-07-16T06:35:11.702Z","comments":true,"path":"2014/11/24/linux-common-command/","link":"","permalink":"https://scutccnl.github.io/2014/11/24/linux-common-command/","excerpt":"一、关于电源reboot 重启logout 注销root 注销后登录","text":"一、关于电源reboot 重启logout 注销root 注销后登录 二、vi管理器编译java程序1.输入vi hello.java2.输入i，进入insert模式3.输入 esc，进入命令模式4.输入 :wq，保存并退出 :q!，退出不保存5.编译 javac hello.java6.运行 java hello简单了解vi自带编辑器后，可以用更强大的编辑器vim，ubuntu中自带，用起来更顺手 三、简单命令1、ls 查看当前目录有什么，ls -l以列的方式查看明细，ls -al列出隐藏的.开头系统文件2、cal 10 2014 查看日期3、man date 查看date 的用法4、在root（不用）权限下改变文件的拥有者，群组 1、chgrp user install.log 改变群组为user，前提为 /etc/group里有user 2、chown root:root install.log 同时改变拥有者和群组为root，前提为 /etc/passwd里有root 主要用在 cp install.log install.logcp 复制操作后，install.logcp的权限什么的都没改 3、chmod 777 install.log 改变权限 r=4 w=2 x=1或者 chmod u=rwx,go=rx install.log 4、chmod a+w install.log 表示使所有都增加写的权限 5、su gugugugjiawei 切换身份6、mkdir testing 建立新目录 mkdir -p tmp1/tmp2 建立空目录tmp1,再建立空目录tmp2于tmp1下 mkdir -m 711 tmp11 指定目录下新建的tmp11的权限为711 rmdir tmp 删除当前目录下的空目录tmp,如果空目录下有tmp1，可以使用rmkir tmp/tmp1，再使用rmdir tmp，或者使用rmdir rm -r tmp 不管是不是空目录，删除掉！ rmdir -p tmp1/tmp2/tmp3 如果tmp3是空目录，先删除tmp3，如果tmp2是空目录，继续删，如果不是，提示并停止 rmdir tmp1/tmp2/tmp3 就只删tmp37、cd ../回到上级目录 8、pwd 显示当前目录 pwd -P 显示正确的路径，即连接档会被连接到什么地方去的完整路径9、nano mytext.txt10、当打开a.txt中文出现乱码可以使用命令 iconv -f gb2312 -t utf-8 a.txt&gt;ab.txt 传输件：PSCP.EXE 传输文件目录 用户名@主机地址：接受文件目录11、mv重命名或移动，cp为复制 mv newtmp movetmp 重命名为movetmp12、bc 计算器13、df 看看是否挂载14、压缩与解压缩 zcat是读取解压后的文件的内容并显示在屏幕上，但没有解压（因为cat可以读取纯文本）gzip newtxt.txt&gt;newtxt.txt.gz 表示newtxt.txt压缩为newtxt.txt.gz，然后再输入n即可保留两个然而，bzip2更优秀，用法类似，不过要压缩的话是bzip2 -z filename 注意：gzip 和bzip2不能压缩文件夹，即不能打包此时就用到了tar 不同点：要自定义档名；小写-p保留权限，建议加上去。 大写-P会加入完整路径，解压后回到原来的地方，可能会导致覆盖原来的文件造成后果。压缩后保留原来文件以后这样写 压缩：tar -jpcv -f filename.tar.bz2 filename 解压：tar -jxv -f filename.tar.bz215.vi编辑器详解 一般编辑模式：（注意a的妙用） L(H) 下(上)一个字符 P换行 u复原上一次动作 . 重复上次操作 3j表示向下跳三行 yy是复制一行 p是粘贴到下一行 要是不小心换行了解决方法：切换为一般模式（esc）+回到上一行（k）+合并下一行（大写J） + delete+end + a 16、关于字体编码装换（P351）","categories":[{"name":"linux","slug":"linux","permalink":"https://scutccnl.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://scutccnl.github.io/tags/linux/"}]},{"title":"浅谈Virtual Box下，ubuntu系统能否被外网访问的问题","slug":"ubuntu-internet","date":"2014-11-21T10:41:00.000Z","updated":"2016-07-16T06:35:11.722Z","comments":true,"path":"2014/11/21/ubuntu-internet/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/ubuntu-internet/","excerpt":"写写记记，不然有时会寻寻觅觅，纠结很久~ 1、Host-Only模式下外网访问不了（因为没有端口映射），虚拟机能上网，主机能利用局域网分配给虚拟机的ip进行访问（ping）","text":"写写记记，不然有时会寻寻觅觅，纠结很久~ 1、Host-Only模式下外网访问不了（因为没有端口映射），虚拟机能上网，主机能利用局域网分配给虚拟机的ip进行访问（ping） 注意：启动服务器记得加上0.0.0.0:port，有时候访问不了服务器，点击右上角的设置查看ip和ifconfig的ip，如果不一样，弄到一样为止，重启或者其他reset操作什么的。 2、网络地址转换(NAT)通过端口映射可以使局域网内的所有计算机可以访问虚拟机中的服务器，手机连接wifi亲测可用（前提是主机ip设置为空），不过不知道非局域网怎样，不过坑爹的校园网是不行的。。。","categories":[{"name":"linux","slug":"linux","permalink":"https://scutccnl.github.io/categories/linux/"}],"tags":[{"name":"virtual box","slug":"virtual-box","permalink":"https://scutccnl.github.io/tags/virtual-box/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://scutccnl.github.io/tags/ubuntu/"}]},{"title":"windows下eclipseNDK开发兼调试环境配置        ","slug":"ndk-setup","date":"2014-11-21T10:35:00.000Z","updated":"2016-07-16T06:35:11.706Z","comments":true,"path":"2014/11/21/ndk-setup/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/ndk-setup/","excerpt":"windows下eclipseNDK开发兼调试环境配置 NDK-r7版本及之后windows下开发NDK开发更加方便。 PS：该环境并没有配置CDT、cygwin、Mingw，因为现在的adt已经有c/c++开发的相关配置了，而ndk又集成了linux的编译环境，装太多东西不保证能成功。","text":"windows下eclipseNDK开发兼调试环境配置 NDK-r7版本及之后windows下开发NDK开发更加方便。 PS：该环境并没有配置CDT、cygwin、Mingw，因为现在的adt已经有c/c++开发的相关配置了，而ndk又集成了linux的编译环境，装太多东西不保证能成功。 原文链接：http://my.oschina.net/u/262922/blog/301513 配置流程如下： 新建一个android工程，等下也不要转为c/c++工程 以下根据具体情况去设置下Application.mk: 以下根据具体情况去设置下 Application.mk: 1234567891011APP_STL := gnustl_staticAPP_CFLAGS += -fexceptions APP_CPPFLAGS +=-std=c++11APP_CPPFLAGS +=-fpermissiveAPP_OPTIM := debugAPP_PLATFORM := android-8 Android.mk:1234567891011121314151617181920212223242526272829303132LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)#APP_STL := gnustl_staticLOCAL_MODULE := WebServiceLOCAL_SRC_FILES := com_http_WebService.cpp \\ MessageProxy.cpp \\ MsgBase.cpp \\ NetQueue.cpp \\ SendOperation.cpp \\ ThreadControl.cpp LOCAL_STATIC_LIBRARIES := stdc++LOCAL_C_INCLUDES := $(LOCAL_PATH)/include LOCAL_LDLIBS := -L$(LOCAL_PATH)/lib -lcurl LOCAL_LDLIBS += -lloginclude $(BUILD_SHARED_LIBRARY) Manifest.xml中application可能要加入才能调试： android:debuggable=”true” 如果要从Android调试到C/C++代码，需要再MainActivity.java的onCreate中加入 android.os.Debug.waitForDebugger(); 然后右键—&gt;Debug As—&gt;Android Native Application开始调试","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://scutccnl.github.io/tags/ndk/"}]},{"title":"android混淆与反射","slug":"android-reflect","date":"2014-11-21T10:32:00.000Z","updated":"2016-07-16T06:35:11.686Z","comments":true,"path":"2014/11/21/android-reflect/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/android-reflect/","excerpt":"android混淆与反射Android包4.0（好像是4.0）以后混淆更加简单 一、配置1、在project.properties.txt将以下内容注释去掉proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt","text":"android混淆与反射Android包4.0（好像是4.0）以后混淆更加简单 一、配置1、在project.properties.txt将以下内容注释去掉proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt 2、在proguard-project中加入取消混淆的声明：需要混淆的jar包所依赖的jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148-libraryjars 'F:\\eclipse\\adt-bundle-windows-x86-20130917\\sdk\\platforms\\android-19\\android.jar'-optimizationpasses 5 # 混淆时不会产生形形色色的类名-dontusemixedcaseclassnames # 指定不去忽略非公共的库类-dontskipnonpubliclibraryclasses # 不预校验-dontpreverify -verbose # 优化-optimizations !code/simplification/arithmetic,!field/*,!class/merging/* # 保留了继承自Activity、Application、Service、BroadcastReceiver、ContentProvider、BackupAgentHelper、Preference和ILicensingService 的子类。因为这些子类，都是可能被外部调用的。-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference-keep public class com.android.vending.licensing.ILicensingService -keep public class * extends android.support.v4.app.FragmentActivity -keep public class * extends android.support.v4.app.Fragmen # 保留了含有native方法的类-keepclasseswithmembernames class * &#123; native &lt;methods&gt;; &#125; # actionbarSherlock 这里要注意了-keep class android.support.v4.app.** &#123; *; &#125; -keep interface android.support.v4.app.** &#123; *; &#125; -keep class com.actionbarsherlock.** &#123; *; &#125; -keep interface com.actionbarsherlock.** &#123; *; &#125; -keepattributes *Annotation* # 保留构造函数从xml构造的类（一般为View的子类）-keepclasseswithmembernames class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet); &#125; # 保留构造函数从xml构造的类（一般为View的子类）-keepclasseswithmembernames class * &#123; public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); &#125; # 保护指定类的成员，如果此类受到保护他们会保护的更好-keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125; # 保留枚举类型中的values和valueOf静态方法-keepclassmembers enum * &#123; public static **[] values(); public static ** valueOf(java.lang.String); &#125; # 保留继承Parcelable的跨进程数据类-keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *; &#125; # 保留反射中用到的类和方法，到时根据具体情况再改# 反编译测试的时候有效，运行时也与未混淆情况一样-keepclassmembers class 包名.** &#123; public *; protected *; private *;&#125; 3、工程中含有第三方jar包，或者.so文件 混淆处理。 -libraryjars libs/apns_1.0.6.jar -libraryjars libs/armeabi/libBaiduMapSDK_v2_3_1.so -libraryjars libs/armeabi/liblocSDK4.so -libraryjars libs/baidumapapi_v2_3_1.jar -libraryjars libs/core.jar -libraryjars libs/gesture-imageview.jar -libraryjars libs/gson-2.0.jar 4、 其它反射调用的java类与方法使用反射时一定要注意proguard可能会认为那些方法未被调用过, 会在代码优化过程中将它们改名或除去. 在使用反射的地方一定要在proguard-project.txt中配置, 不优化反射调用过的类和方法 下面开始打包（不打包你就算设置了其实也没有混淆，不信可以解混淆试试，能成功解混淆） 二、在jdk的bin目录下生成.keystore证书，输入相关资料，记住口令。这里有图，看不到而已，到很久之前的博客可以看到。 三、右键—&gt;Android Tools—&gt;Export signed Application package这里有图，看不到而已，到很久之前的博客可以看到。","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"reflect","slug":"reflect","permalink":"https://scutccnl.github.io/tags/reflect/"}]},{"title":"androidNDK开发之JNI学习        ","slug":"ndk-study","date":"2014-11-21T10:30:00.000Z","updated":"2016-07-16T06:35:11.710Z","comments":true,"path":"2014/11/21/ndk-study/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/ndk-study/","excerpt":"androidNDK开发之JNI学习 1、在工程目录下编译1javah -classpath F:\\eclipse\\adt-bundle-windows-x86-201309017\\sdk\\platforms\\android-19\\android.jar;bin/classes com.example.jnithread.MainActivity","text":"androidNDK开发之JNI学习 1、在工程目录下编译1javah -classpath F:\\eclipse\\adt-bundle-windows-x86-201309017\\sdk\\platforms\\android-19\\android.jar;bin/classes com.example.jnithread.MainActivity 2、增加log信息的方法 在.c文件中添加 12345#define LOG_TAG \"System.out.cpp\"#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__) 在配置mk文件增加 123#liblog.so libGLESv2.soLOCAL_LDLIBS += -llog e.g 1LOGD(\"x=%d\",x); 3、类型转换 4、对象传递机制 假如类为c/c++类，并开始在c/c++程序建立： 返回对象以jlong 类型强制转换对象的指针值，从而将c/c++的对象返回到java中以long变量保存起来，以便后续工作回调c/c++中的对象。 e.g123456789dataInCpp * data1=new dataIntCpp();return (jlong)data1;////////////////////////////////////////jlong data1;dataInCpp * data2 = (dataInCpp *)data1; 假如类为java类，通过c/c++程序创建 A、在c++中创建并返回给java程序12345678910111213141516171819202122232425Jclass clazz = env-&gt;FindClass(“com/example/jnithread/myData”);If(!clazz)&#123;return NULL;&#125;jmethodID constr = env-&gt;GetMethodID(clazz,”&lt;init&gt;”,”()V”);if(!constr)&#123;return;&#125;jobject newObj = env-&gt;NewObject(clazz,constr);if(!newObj)&#123;return;&#125; return newObj; 在java程序中直接用类型myData接收即可，无需用Object B、将c++中创建的java对象再传回给c++方法1jclass clazz = env-&gt;GetObjectClass(dataObject); 接下来和调用java类中函数一样如下所述 5、简单说明一下c++调用java函数：非静态方法调用12345678910111213141516171819202122232425262728293031jclass dpclazz = env-&gt;FindClass(”com/example/jnithreads/MainActivity”);if(dpclazz==0)&#123;LOGI(“find class error”);return;&#125;//去得到函数的信息 javap –s com.example.jnithreads.MainActivityjmethod method1 = env-&gt;GetMethodID(dpclazz,”getNum”,(参数)V); //获取非静态方法的ID//V代表返回类型为void,也可(II)I,表示接收两个int方法返回int类型//如果是String类型的参数写为(Ljava/lang/String;),如果返回类型为byte数组则写为[B If(method1==0)&#123;LOGI(“find method1 error”);Return;&#125;env-&gt;CallVoidMethod(obj,method1);//Void表示返回类型为void//int result = env-&gt;CallVoidMethod(obj,method1,3,5); 后面为参数 注： 1/返回类型定义 2/如果要调用类似【”hello”.getBytes(“gb2312”);】则需要1env-&gt;CallVoidMethod(obj,”hello”,method1,”gb2312”);//”~”要先转换为jstring 3/ byteArray-&gt;char *123456789jsize len = env-&gt;GetArrayLength(byteArray);jbyte* ba = env-&gt;GetByteArrayElements(byteArray,JNI_FALSE);if(len&gt;0)&#123; char * rtn = (char *)malloc(len+1); memcpy(rtn,ba,len); rth[len]=0;&#125;env-&gt;ReleaseByteArrayElements(byteArray,ba,0);//释放掉内存空间return rtn; 4/获取java对象的ID为:12jfieldID field_a=env-&gt;GetFieldID(dpclazz,”a”,”I”);int ma=(int)env-&gt;GetObjectField(obj,field_a);//调用以获得值 静态方法调用： 获取非静态方法的ID：1jmethod methodID = env-&gt;GetStaticMethodID(dpclazz,”getNum”,(参数)V); 调用静态方法：1env-&gt;CallStaticVoidMethod(dpclazz,mthodID,参数) 熟记：get 参数 clazz call参数 obj,methodID 如果是static的话，call前面obj改为clazz 6、全局变量 Jobject的子类别包括jclass、jstring,、jarray(这些类称为局部性的对象参考)，他们就算定义成static，也要利用函数：1gObj = env-&gt;NewGlobalRef(obj);将其赋值从而保持全局性 7、JNI线程模式的调用8、利用C++回调来更新UI(Handler) 同步锁：(java调用c++) 1、定义的时候：1private native synchronized String execute(Object oSync); 进入函数资源调用时：1env-&gt;MonitorEnter(syncObj); 释放时：1env-&gt;MonitorExit(syncObj); 上面讲的是不同线程情况下将对象传入C++程序，所以还是与线程安全有关 如果是在c++程序中的多线程，也一样。 多线程注意：12345if (0 == gVm-&gt;AttachCurrentThread(&amp;env, NULL))&#123;gVm-&gt;DetachCurrentThread();……&#125;","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"ndk","slug":"ndk","permalink":"https://scutccnl.github.io/tags/ndk/"}]},{"title":"关于django的几篇文章","slug":"django-csdn","date":"2014-11-21T10:28:00.000Z","updated":"2016-07-16T06:35:11.690Z","comments":true,"path":"2014/11/21/django-csdn/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/django-csdn/","excerpt":"摘自CSDN，不小心把源文件删了，就不直接贴了","text":"摘自CSDN，不小心把源文件删了，就不直接贴了 django分页技术Paginator（进阶篇）【python web学习】python web窥探django分页技术django-pagination和Paginator（基础篇）ubuntu下发布Django Web的两种方法django之数据库(sqlite3, mongoDB)应用Django Web开发环境的搭建（二）Django Web开发环境的搭建（一）","categories":[{"name":"django","slug":"django","permalink":"https://scutccnl.github.io/categories/django/"}],"tags":[{"name":"CSDN","slug":"CSDN","permalink":"https://scutccnl.github.io/tags/CSDN/"}]},{"title":"android利用ListView滑动刷新        ","slug":"android-listview","date":"2014-11-21T10:28:00.000Z","updated":"2016-07-16T06:35:11.682Z","comments":true,"path":"2014/11/21/android-listview/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/android-listview/","excerpt":"滑动刷新","text":"滑动刷新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.laohuai.appdemo.customui; import java.util.ArrayList; import java.util.List; import com.laohuai.appdemo.customui.ui.MyListView; import com.laohuai.appdemo.customui.ui.MyListView.OnRefreshListener; import android.app.Activity; import android.os.AsyncTask; import android.os.Bundle; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.TextView; public class MainActivity extends Activity &#123; private List&lt;String&gt; data; private BaseAdapter adapter; public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); data = new ArrayList&lt;String&gt;(); data.add(\"a\"); data.add(\"b\"); data.add(\"c\"); data.add(\"a\"); data.add(\"b\"); final MyListView listView = (MyListView) findViewById(R.id.listView); adapter = new BaseAdapter() &#123; public View getView(int position, View convertView, ViewGroup parent) &#123; TextView tv = new TextView(getApplicationContext()); tv.setText(data.get(position)); return tv; &#125; public long getItemId(int position) &#123; return 0; &#125; public Object getItem(int position) &#123; return null; &#125; public int getCount() &#123; return data.size(); &#125; &#125;; listView.setAdapter(adapter); listView.setonRefreshListener(new OnRefreshListener() &#123; public void onRefresh() &#123; new AsyncTask&lt;Void, Void, Void&gt;() &#123; protected Void doInBackground(Void... params) &#123; try &#123; Thread.sleep(3000);//刷新3秒 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; data.add(\"刷新后添加的内容\"); return null; &#125; @Override protected void onPostExecute(Void result) &#123; adapter.notifyDataSetChanged(); listView.onRefreshComplete(); &#125; &#125;.execute(null,null,null); &#125; &#125;); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404package com.laohuai.appdemo.customui.ui; import java.util.Date; import com.laohuai.appdemo.customui.R; import android.content.Context; import android.util.AttributeSet; import android.util.Log; import android.view.LayoutInflater; import android.view.MotionEvent; import android.view.View; import android.view.ViewGroup; import android.view.animation.LinearInterpolator; import android.view.animation.RotateAnimation; import android.widget.AbsListView; import android.widget.BaseAdapter; import android.widget.ImageView; import android.widget.LinearLayout; import android.widget.ListView; import android.widget.AbsListView.OnScrollListener; import android.widget.ProgressBar; import android.widget.TextView; public class MyListView extends ListView implements OnScrollListener &#123; private static final String TAG = \"listview\"; private final static int RELEASE_To_REFRESH = 0; private final static int PULL_To_REFRESH = 1; private final static int REFRESHING = 2; private final static int DONE = 3; private final static int LOADING = 4; // 实际的padding的距离与界面上偏移距离的比例 private final static int RATIO = 3; private LayoutInflater inflater; //一个线性布局类对象，设置一个可选布局区域 private LinearLayout headView; private TextView tipsTextview; private TextView lastUpdatedTextView; private ImageView arrowImageView; private ProgressBar progressBar; private RotateAnimation animation; private RotateAnimation reverseAnimation; // 用于保证startY的值在一个完整的touch事件中只被记录一次 private boolean isRecored; private int headContentWidth; private int headContentHeight; private int startY; private int firstItemIndex; private int state; private boolean isBack; private OnRefreshListener refreshListener; private boolean isRefreshable; //新建时自动调用构造函数 public MyListView(Context context) &#123; super(context); init(context); &#125; //新建时自动调用构造函数 public MyListView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context); &#125; private void init(Context context) &#123; //拖动时背景黑色设置 setCacheColorHint(context.getResources().getColor(R.color.transparent)); //---------设置项目前面的显示--------- inflater = LayoutInflater.from(context); headView = (LinearLayout) inflater.inflate(R.layout.head, null); //获取箭头对象 arrowImageView = (ImageView) headView .findViewById(R.id.head_arrowImageView); arrowImageView.setMinimumWidth(70); arrowImageView.setMinimumHeight(50); //进度条 progressBar = (ProgressBar) headView .findViewById(R.id.head_progressBar); //下拉刷新、上拉刷新 tipsTextview = (TextView) headView.findViewById(R.id.head_tipsTextView); //最近更新 lastUpdatedTextView = (TextView) headView .findViewById(R.id.head_lastUpdatedTextView); measureView(headView); headContentHeight = headView.getMeasuredHeight(); headContentWidth = headView.getMeasuredWidth(); //和父类比较，（上下左右）的view之间的距离 headView.setPadding(0, -1 * headContentHeight, 0, 0); headView.invalidate(); Log.v(\"size\", \"width:\" + headContentWidth + \" height:\" + headContentHeight); //下面两句极其重要，一方面将listView和headView绑定，一方面监听操作 addHeaderView(headView, null, false); setOnScrollListener(this); //下面没看懂，待查 animation = new RotateAnimation(0, -180, RotateAnimation.RELATIVE_TO_SELF, 0.5f, RotateAnimation.RELATIVE_TO_SELF, 0.5f); animation.setInterpolator(new LinearInterpolator()); animation.setDuration(250); animation.setFillAfter(true); reverseAnimation = new RotateAnimation(-180, 0, RotateAnimation.RELATIVE_TO_SELF, 0.5f, RotateAnimation.RELATIVE_TO_SELF, 0.5f); reverseAnimation.setInterpolator(new LinearInterpolator()); reverseAnimation.setDuration(200); reverseAnimation.setFillAfter(true); state = DONE; isRefreshable = false; &#125; public void onScroll(AbsListView arg0, int firstVisiableItem, int arg2, int arg3) &#123; //滚动时一直回调，直到停止滚动时才停止回调。单击时不回调。刷新 //onTouchEvent调用后总会回调一次 //firstVisibleItem：当前能看见的第一个列表项ID（从0开始），总是0 //arg2：当前能看见的列表项个数（小半个也算）listView个数 //arg3：列表项共数,listView个数 //Log.d(TAG,\"firstItemIndex:\"+firstItemIndex); firstItemIndex = firstVisiableItem; &#125; //点击或滑动都会触发 public void onScrollStateChanged(AbsListView arg0, int arg1) &#123; &#125; public boolean onTouchEvent(MotionEvent event) &#123; if (isRefreshable) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (firstItemIndex == 0 &amp;&amp; !isRecored) &#123; isRecored = true; startY = (int) event.getY(); Log.v(TAG, \"在down时候记录当前位置‘\"); &#125; break; case MotionEvent.ACTION_UP: if (state != REFRESHING &amp;&amp; state != LOADING) &#123; if (state == DONE) &#123; // 什么都不做 &#125; if (state == PULL_To_REFRESH) &#123; state = DONE; changeHeaderViewByState(); //有下拉但没刷新 Log.v(TAG, \"由下拉刷新状态，到done状态\"); &#125; if (state == RELEASE_To_REFRESH) &#123; state = REFRESHING; //因为异步执行，所以下面两句一起进行，由onRefresh决定什么时候改变状态， //因为会调用onRefreshComplete() changeHeaderViewByState(); onRefresh(); //有下拉并且刷新 Log.v(TAG, \"由松开刷新状态，到done状态\"); &#125; &#125; isRecored = false; isBack = false; break; //当触摸时移动操作时调用 case MotionEvent.ACTION_MOVE: int tempY = (int) event.getY(); if (!isRecored &amp;&amp; firstItemIndex == 0) &#123; Log.v(TAG, \"在move时候记录下位置\"); isRecored = true; startY = tempY; &#125; if (state != REFRESHING &amp;&amp; isRecored &amp;&amp; state != LOADING) &#123; // 保证在设置padding的过程中，当前的位置一直是在head，否则如果当列表超出屏幕的话，当在上推的时候，列表会同时进行滚动 // 可以松手去刷新了 if (state == RELEASE_To_REFRESH) &#123; setSelection(0); // 往上推了，推到了屏幕足够掩盖head的程度，但是还没有推到全部掩盖的地步 if (((tempY - startY) / RATIO &lt; headContentHeight) &amp;&amp; (tempY - startY) &gt; 0) &#123; state = PULL_To_REFRESH; changeHeaderViewByState(); Log.v(TAG, \"由松开刷新状态转变到下拉刷新状态\"); &#125; // 一下子推到顶了 else if (tempY - startY &lt;= 0) &#123; state = DONE; changeHeaderViewByState(); Log.v(TAG, \"由松开刷新状态转变到done状态\"); &#125; // 往下拉了，或者还没有上推到屏幕顶部掩盖head的地步 else &#123; // 不用进行特别的操作，只用更新paddingTop的值就行了 &#125; &#125; // 还没有到达显示松开刷新的时候,DONE或者是PULL_To_REFRESH状态 if (state == PULL_To_REFRESH) &#123; setSelection(0); // 下拉到可以进入RELEASE_TO_REFRESH的状态 if ((tempY - startY) / RATIO &gt;= headContentHeight) &#123; state = RELEASE_To_REFRESH; isBack = true; changeHeaderViewByState(); Log.v(TAG, \"由done或者下拉刷新状态转变到松开刷新\"); &#125; // 上推到顶了 else if (tempY - startY &lt;= 0) &#123; state = DONE; changeHeaderViewByState(); Log.v(TAG, \"由DOne或者下拉刷新状态转变到done状态\"); &#125; &#125; // done状态下 if (state == DONE) &#123; if (tempY - startY &gt; 0) &#123; state = PULL_To_REFRESH; changeHeaderViewByState(); &#125; &#125; // 更新headView的size if (state == PULL_To_REFRESH) &#123; headView.setPadding(0, -1 * headContentHeight + (tempY - startY) / RATIO, 0, 0); &#125; // 更新headView的paddingTop if (state == RELEASE_To_REFRESH) &#123; headView.setPadding(0, (tempY - startY) / RATIO - headContentHeight, 0, 0); &#125; &#125; break; &#125; &#125; return super.onTouchEvent(event); &#125; // 当状态改变时候，调用该方法，以更新界面 private void changeHeaderViewByState() &#123; switch (state) &#123; case RELEASE_To_REFRESH: arrowImageView.setVisibility(View.VISIBLE); progressBar.setVisibility(View.GONE); tipsTextview.setVisibility(View.VISIBLE); lastUpdatedTextView.setVisibility(View.VISIBLE); arrowImageView.clearAnimation(); //方向 arrowImageView.startAnimation(animation); tipsTextview.setText(\"松开刷新\"); Log.v(TAG, \"当前状态，松开刷新\"); break; case PULL_To_REFRESH: progressBar.setVisibility(View.GONE); tipsTextview.setVisibility(View.VISIBLE); lastUpdatedTextView.setVisibility(View.VISIBLE); arrowImageView.clearAnimation(); arrowImageView.setVisibility(View.VISIBLE); // 是由RELEASE_To_REFRESH状态转变来的 if (isBack) &#123; isBack = false; arrowImageView.clearAnimation(); //方向 arrowImageView.startAnimation(reverseAnimation); tipsTextview.setText(\"下拉刷新\"); &#125; else &#123; tipsTextview.setText(\"下拉刷新\"); &#125; Log.v(TAG, \"当前状态，下拉刷新\"); break; case REFRESHING: headView.setPadding(0, 0, 0, 0); progressBar.setVisibility(View.VISIBLE); arrowImageView.clearAnimation(); arrowImageView.setVisibility(View.GONE); tipsTextview.setText(\"正在刷新...\"); lastUpdatedTextView.setVisibility(View.VISIBLE); Log.v(TAG, \"当前状态,正在刷新...\"); break; case DONE: headView.setPadding(0, -1 * headContentHeight, 0, 0); progressBar.setVisibility(View.GONE); arrowImageView.clearAnimation(); arrowImageView.setImageResource(R.drawable.arrow); tipsTextview.setText(\"下拉刷新\"); lastUpdatedTextView.setVisibility(View.VISIBLE); Log.v(TAG, \"当前状态，done\"); break; &#125; &#125; public void setonRefreshListener(OnRefreshListener refreshListener) &#123; this.refreshListener = refreshListener; isRefreshable = true; &#125; public interface OnRefreshListener &#123; public void onRefresh(); &#125; public void onRefreshComplete() &#123; state = DONE; lastUpdatedTextView.setText(\"最近更新:\" + new Date().toLocaleString()); changeHeaderViewByState(); &#125; private void onRefresh() &#123; if (refreshListener != null) &#123; refreshListener.onRefresh(); &#125; &#125; // 此方法直接照搬自网络上的一个下拉刷新的demo，此处是“估计”headView的width以及height //1.static int getMode(int measureSpec):根据提供的测量值(格式)提取模式(上述三个模式之一) //2.static int getSize(int measureSpec):根据提供的测量值(格式)提取大小值(这个大小也就是我们通常所说的大小) //3.static int makeMeasureSpec(int size,int mode):根据提供的大小值和模式创建一个测量值(格式) private void measureView(View child) &#123; ViewGroup.LayoutParams p = child.getLayoutParams(); if (p == null) &#123; p = new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); &#125; int childWidthSpec = ViewGroup.getChildMeasureSpec(0, 0 + 0, p.width); int lpHeight = p.height; //高度格式 // 一个MeasureSpec封装了父布局传递给子布局的布局要求 int childHeightSpec; if (lpHeight &gt; 0) &#123; //EXACTLY(完全)，父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小 childHeightSpec = MeasureSpec.makeMeasureSpec(lpHeight, MeasureSpec.EXACTLY); Log.d(TAG,\"lpHeight:\"+ lpHeight); &#125; else &#123; //UNSPECIFIED(未指定),在高度上父元素不对子元素施加任何束缚 childHeightSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); //测试的时候发现是-2 Log.d(TAG,\"lpHeight:\"+ lpHeight); &#125; //宽度保持不变 //测试的时候childWidthSpec, childHeightSpec都是0 child.measure(childWidthSpec, childHeightSpec); &#125; public void setAdapter(BaseAdapter adapter) &#123; lastUpdatedTextView.setText(\"最近更新:\" + new Date().toLocaleString()); super.setAdapter(adapter); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!-- ListView的头部 --&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" &gt; &lt;!-- 内容 --&gt; &lt;RelativeLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/head_contentLayout\" android:paddingLeft=\"30dp\" &gt; &lt;!-- 箭头图像、进度条 --&gt; &lt;FrameLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_centerVertical=\"true\" &gt; &lt;!-- 箭头 --&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:src=\"@drawable/arrow\" android:id=\"@+id/head_arrowImageView\" /&gt; &lt;!-- 进度条 --&gt; &lt;ProgressBar android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" style=\"?android:attr/progressBarStyleSmall\" android:layout_gravity=\"center\" android:id=\"@+id/head_progressBar\" android:visibility=\"gone\" /&gt; &lt;/FrameLayout&gt; &lt;!-- 提示、最近更新 --&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:orientation=\"vertical\" android:gravity=\"center_horizontal\" &gt; &lt;!-- 提示 --&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"下拉刷新\" android:textColor=\"@color/white\" android:textSize=\"20sp\" android:id=\"@+id/head_tipsTextView\" /&gt; &lt;!-- 最近更新 --&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/head_lastUpdatedTextView\" android:text=\"最近更新\" android:textColor=\"@color/gold\" android:textSize=\"10sp\" /&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:background=\"#000066\" android:orientation=\"vertical\" &gt; &lt;com.laohuai.appdemo.customui.ui.MyListView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:id=\"@+id/listView\" /&gt; &lt;/LinearLayout&gt;","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"listview","slug":"listview","permalink":"https://scutccnl.github.io/tags/listview/"}]},{"title":"利用简易Tomcat服务器结合MysqL实现Android手机注册与登录(服务器部分)        ","slug":"tomcat-server","date":"2014-11-21T10:27:00.000Z","updated":"2016-07-16T06:35:11.722Z","comments":true,"path":"2014/11/21/tomcat-server/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/tomcat-server/","excerpt":"一、概述1、服务器在本地搭建，利用Tomcat运行servlet容器2、继承于httpServlet类的自定义实现与客户端的交互，结合MysqL，jdbc知识3、客户端实现简单的注册和登录验证","text":"一、概述1、服务器在本地搭建，利用Tomcat运行servlet容器2、继承于httpServlet类的自定义实现与客户端的交互，结合MysqL，jdbc知识3、客户端实现简单的注册和登录验证注意点：1、web.xml里入口定义要正确，否则登录客户端连接不到2、当在Tomcat中运行时，需要在WEB_INF文件夹中手动添加jdbc库文件，偶尔会在运行过后消失，要注意。（或者直接脱离Eclipse就不会有这个问题）3、sql语句要多测试，否则容易写错但执行不会报错。4、注意事先需启动MysqL。 二、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com; import java.io.IOException; import java.io.PrintWriter; import java.sql.*; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; &lt;!--more--&gt;public class JavaRegisterMysql extends HttpServlet&#123; private static final long serialVersionUID = 1L; private static final int NAME_CODE_RIGHT = 0; // private static final int CODE_WRONG = 1; // private static final int NAME_WRONG = 2; // String notename = null; String notepassword = null; String notephone = null; public JavaRegisterMysql()&#123; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub if(req == null)&#123; return; &#125; resp.setContentType(\"text/html;charset=utf-8\"); req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); PrintWriter out = resp.getWriter(); String name = req.getParameter(\"NAME\"); String code = req.getParameter(\"CODE\"); String phone = req.getParameter(\"PHONE\"); String chose=req.getParameter(\"CHOSE\"); //手机客户端访问 int ret=-1; try &#123; ret = checkSubmit(name, code, phone, chose); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; out.print(ret); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // TODO Auto-generated method stub if(req == null)&#123; return; &#125; resp.setContentType(\"text/html;charset=utf-8\"); req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); PrintWriter out = resp.getWriter(); String name = req.getParameter(\"NAME\"); String code = req.getParameter(\"CODE\"); String phone = req.getParameter(\"PHONE\"); String chose=req.getParameter(\"CHOSE\"); int ret=-2; try &#123; ret = checkSubmit(name, code, phone,chose); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; out.print(ret); out.flush(); out.close(); &#125; /** * 判断登录名和密码 * @param name * @param code * @return * @throws Exception */ private int checkSubmit(String name, String code, String phone,String chose) throws Exception&#123; int ret = -1; //UserDAOProxy ab=new UserDAOProxy(); User user=new User(name,code,phone); ret=new UserDAOProxy().findLogin(user, chose); return ret; &#125; &#125; 主接收类 1234567891011121314151617181920212223242526272829package com; import java.sql.*; public class DatabaseConnection &#123; public static final String DRIVER = \"com.mysql.jdbc.Driver\"; public static final String URL = \"jdbc:mysql://localhost:3306/scut\"; public static final String USER = \"root\"; public static final String PASS = \"123456\"; private Connection con; public DatabaseConnection()&#123; try&#123; Class.forName(DRIVER); con = DriverManager.getConnection(URL,USER,PASS); &#125; catch(Exception e)&#123;&#125; &#125; public Connection getConnection()&#123; return con; &#125; public void close()&#123; try&#123; if(con!=null)&#123; con.close(); &#125; &#125; catch(Exception e)&#123;&#125; &#125; &#125; JDBC接口类 123456789101112131415package com; public class UserDAOProxy &#123; private DatabaseConnection dbc; private UserDAOImpl idao; public UserDAOProxy()&#123; dbc = new DatabaseConnection(); idao = new UserDAOImpl(dbc.getConnection()); &#125; public int findLogin(User user,String chose)throws Exception&#123; int flag = idao.findLogin(user,chose); dbc.close(); return flag; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com; import java.sql.*; public class UserDAOImpl &#123; private Connection con; private Statement stat; public UserDAOImpl(Connection con)&#123; this.con = con; &#125; public int findLogin(User user,String chose)throws Exception&#123; int flag = 0; //String sql = \"SELECT * FROM noteinfo WHERE name=\"+\"'\"+user.getName()+\"'\"; //String sql = \"SELECT * FROM noteinfo WHERE id=1\"; //String cd=user.getName(); //String sql = \"SELECT * FROM noteinfo WHERE name=\"+ \"'\"+user.getName()+\"'\" + // \" and password=\"+ \"'\"+user.getPassword()+\"'\"; try &#123; this.stat = con.createStatement(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 结果集 if(chose.equals(\"1\")) &#123; flag=1; String sql = \"SELECT * FROM noteinfo WHERE name=\"+ \"'\"+user.getName()+\"'\" + \" and password=\"+ \"'\"+user.getPassword()+\"'\"; //String sql2=\"insert into noteinfo values(null,'ggg','111','13412323234')\"; ResultSet rs = stat.executeQuery(sql); if(rs.next())&#123; user.setName(rs.getString(\"name\")); user.setPassword(rs.getString(\"password\")); flag = 2; &#125; //stat.execute(sql2); &#125; if(chose.equals(\"2\")) &#123; flag=3; String sql=\"insert into noteinfo values(null,\"+ \"'\"+user.getName()+ \"'\"+\",\"+ \"'\"+user.getPassword()+ \"'\"+\",\" + \"'\"+user.getPhone()+ \"')\"; stat.execute(sql); flag = 4; &#125; return flag; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435package com; public class User &#123; public User()&#123; this.name=\" \"; this.password=\" \"; this.phone=\" \"; &#125; public User(String name,String code,String phone)&#123; this.name=name; this.password=code; this.phone=phone; &#125; private String phone; private String name; private String password; public String getPhone()&#123; return phone; &#125; public void setPhone(String phone)&#123; this.phone = phone; &#125; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; public void setPassword(String password)&#123; this.password = password; &#125; public String getPassword()&#123; return password; &#125; &#125; 以上为相应调用类 12345678&lt;servlet&gt; &lt;servlet-name&gt;gjwServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.JavaRegisterMysql&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;gjwServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; web.xml需添加以上部分代码","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://scutccnl.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"https://scutccnl.github.io/tags/servlet/"}]},{"title":"利用简易Tomcat服务器结合MysqL实现Android手机注册与登录(客户端部分)        ","slug":"tomcat-client","date":"2014-11-21T10:22:00.000Z","updated":"2016-07-16T06:35:11.722Z","comments":true,"path":"2014/11/21/tomcat-client/","link":"","permalink":"https://scutccnl.github.io/2014/11/21/tomcat-client/","excerpt":"一、概述1、服务器在本地搭建，利用Tomcat运行servlet容器2、继承于httpServlet类的自定义实现与客户端的交互，结合MysqL，jdbc知识3、客户端实现简单的注册和登录验证","text":"一、概述1、服务器在本地搭建，利用Tomcat运行servlet容器2、继承于httpServlet类的自定义实现与客户端的交互，结合MysqL，jdbc知识3、客户端实现简单的注册和登录验证注意点：1、web.xml里入口定义要正确，否则登录客户端连接不到2、当在Tomcat中运行时，需要在WEB_INF文件夹中手动添加jdbc库文件，偶尔会在运行过后消失，要注意。（或者直接脱离Eclipse就不会有这个问题）3、sql语句要多测试，否则容易写错但执行不会报错。4、注意事先需启动MysqL。 二、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.example.java4androidmysql; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.List; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.HttpClient; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.params.ConnManagerParams; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; import android.os.AsyncTask; import android.os.Bundle; import android.app.Activity; import android.content.Intent; import android.view.Menu; import android.view.View; import android.view.Window; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; public class MainActivity extends Activity &#123; public static final String URL = \"http://192.168.2.1:8080/JavaRegisterMysql/login\"; public static String res=\"\"; public static String name = \"\"; public static String code = \"\"; public static String phone =\" \"; public static String chose=\"0\"; Button connectButton=null; Button registerButton=null; EditText noteUser=null; EditText notePassword=null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); connectButton=(Button)findViewById(R.id.btnConnect); registerButton=(Button)findViewById(R.id.btnRegister); noteUser=(EditText)findViewById(R.id.editUserName); notePassword=(EditText)findViewById(R.id.editPassword); //////注意类Class DriverManager Statement ResultSet connectButton.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; Toast.makeText(MainActivity.this, \"正在登录\", Toast.LENGTH_SHORT).show(); name = noteUser.getText().toString().trim(); code = notePassword.getText().toString().trim(); chose=\"1\"; new SubmitAsyncTask().execute(URL); Toast.makeText(MainActivity.this, \"res = \"+res, Toast.LENGTH_SHORT).show(); if(res.equals(\"2\"))&#123; Toast.makeText(MainActivity.this, \"登录成功\", Toast.LENGTH_SHORT).show(); //Intent intent=new Intent(); //intent.setClass(MainActivity.this, WriteNote.class); //MainActivity.this.startActivity(intent); &#125;else if(res.equals(\"1\"))&#123; Toast.makeText(MainActivity.this, \"用户名或密码错误\", Toast.LENGTH_SHORT).show(); &#125;else if(res.equals(\"3\"))&#123; Toast.makeText(MainActivity.this, \"注册失败\", Toast.LENGTH_SHORT).show(); &#125;else if(res.equals(\"4\"))&#123; Toast.makeText(MainActivity.this, \"注册成功\", Toast.LENGTH_SHORT).show(); &#125;else if(res.equals(\"-1\"))&#123; Toast.makeText(MainActivity.this, \"网络异常\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); noteUser.setText(\"ab\"); notePassword.setText(\"123456\"); registerButton.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; Intent intent=new Intent(); intent.setClass(MainActivity.this, Register.class); MainActivity.this.startActivity(intent); &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; &#125; 以上为手机主界面函数调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.example.java4androidmysql; import android.app.Activity; import android.os.Bundle; import android.view.View; import android.view.Window; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; public class Register extends Activity&#123; public static final String URL = \"http://192.168.2.1:8080/JavaRegisterMysql/login\"; Button backButton=null; Button registerButton=null; EditText user=null; EditText password=null; EditText phone=null; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.register); backButton=(Button)findViewById(R.id.btnBack); registerButton=(Button)findViewById(R.id.btnRegister); user=(EditText)findViewById(R.id.editUserName); password=(EditText)findViewById(R.id.editPassword); phone=(EditText)findViewById(R.id.editPhone); //////注意类Class DriverManager Statement ResultSet registerButton.setOnClickListener(new View.OnClickListener() &#123; public void onClick(View v) &#123; MainActivity.name = user.getText().toString().trim(); MainActivity.code = password.getText().toString().trim(); MainActivity.phone = phone.getText().toString().trim(); MainActivity.chose=\"2\"; new SubmitAsyncTask().execute(URL); Toast.makeText(Register.this, \"res = \"+MainActivity.res, Toast.LENGTH_SHORT).show(); if(MainActivity.res.equals(\"2\"))&#123; Toast.makeText(Register.this, \"登录成功\", Toast.LENGTH_SHORT).show(); //Intent intent=new Intent(); //intent.setClass(MainActivity.this, WriteNote.class); //MainActivity.this.startActivity(intent); &#125;else if(MainActivity.res.equals(\"1\"))&#123; Toast.makeText(Register.this, \"用户名或密码错误\", Toast.LENGTH_SHORT).show(); &#125;else if(MainActivity.res.equals(\"3\"))&#123; Toast.makeText(Register.this, \"注册失败\", Toast.LENGTH_SHORT).show(); &#125;else if(MainActivity.res.equals(\"4\"))&#123; Toast.makeText(Register.this, \"注册成功\", Toast.LENGTH_SHORT).show(); &#125;else if(MainActivity.res.equals(\"-1\"))&#123; Toast.makeText(Register.this, \"网络异常\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); user.setText(\"gjw\"); password.setText(\"123\"); phone.setText(\"13570236302\"); &#125; &#125; 以上为注册界面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.example.java4androidmysql; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.List; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.HttpClient; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.params.ConnManagerParams; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpConnectionParams; import org.apache.http.params.HttpParams; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; import android.os.AsyncTask; public class SubmitAsyncTask extends AsyncTask&lt;String, Integer, String&gt;&#123; String info = \"\"; protected String doInBackground(String... params) &#123; // TODO Auto-generated method stub String url = params[0]; String reps = \"\"; reps = doPost(url); return reps; &#125; protected void onPostExecute(String result) &#123; // TODO Auto-generated method stub MainActivity.res = result.trim(); super.onPostExecute(result); &#125; /** * 用Post方式跟服务器传递数据 * @param url * @return */ private String doPost(String url)&#123; String responseStr = \"\"; try &#123; //发送post类型请求 HttpPost httpRequest = new HttpPost(url); HttpParams params = new BasicHttpParams(); ConnManagerParams.setTimeout(params, 1000); //从连接池中获取连接的超时时间 HttpConnectionParams.setConnectionTimeout(params, 3000);//通过网络与服务器建立连接的超时时间 HttpConnectionParams.setSoTimeout(params, 5000);//读响应数据的超时时间 httpRequest.setParams(params); //下面开始跟服务器传递数据，使用BasicNameValuePair List&lt;BasicNameValuePair&gt; paramsList = new ArrayList&lt;BasicNameValuePair&gt;(); paramsList.add(new BasicNameValuePair(\"NAME\", MainActivity.name)); paramsList.add(new BasicNameValuePair(\"CODE\", MainActivity.code)); paramsList.add(new BasicNameValuePair(\"PHONE\", MainActivity.phone)); paramsList.add(new BasicNameValuePair(\"CHOSE\", MainActivity.chose)); UrlEncodedFormEntity mUrlEncodeFormEntity = new UrlEncodedFormEntity(paramsList, HTTP.UTF_8); httpRequest.setEntity(mUrlEncodeFormEntity); //////////////////////////////////////////////// HttpClient httpClient = new DefaultHttpClient(); HttpResponse httpResponse = httpClient.execute(httpRequest); final int ret = httpResponse.getStatusLine().getStatusCode(); if(ret == HttpStatus.SC_OK)&#123; responseStr = EntityUtils.toString(httpResponse.getEntity(), HTTP.UTF_8); &#125;else&#123; responseStr = \"-1\"; &#125; &#125; catch (UnsupportedEncodingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ClientProtocolException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return responseStr; &#125; &#125; 以上为接口类，但写得可能有些不对（如返回变量那里是上次调用的），略忙，等再改一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"vertical\" android:background=\"@drawable/ab\" &gt; &lt;TextView android:id=\"@+id/FRppt01\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/Title\" android:textSize=\"15pt\" android:textColor=\"#FFFFFF\" android:textStyle=\"bold\" android:layout_marginTop=\"40dp\" android:gravity=\"center_horizontal\" android:padding=\"3dip\"/&gt; &lt;EditText android:id=\"@+id/editUserName\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:hint=\"输入用户名\"/&gt; &lt;EditText android:id=\"@+id/editPassword\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:hint=\"输入密码\"/&gt; &lt;TableLayout android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;TableRow&gt; &lt;Button android:id=\"@+id/btnConnect\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"登录\" android:layout_marginTop=\"260dp\" android:layout_weight=\"1\" /&gt; &lt;Button android:id=\"@+id/btnRegister\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"注册\" android:layout_marginTop=\"260dp\" android:layout_weight=\"1\"/&gt;\" &lt;/TableRow&gt; &lt;/TableLayout&gt; &lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"vertical\" android:background=\"@drawable/ab\" &gt; &lt;TextView android:id=\"@+id/FRppt01\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/RegisterPage\" android:textSize=\"15pt\" android:textColor=\"#FFFFFF\" android:textStyle=\"bold\" android:layout_marginTop=\"40dp\" android:gravity=\"center_horizontal\" android:padding=\"3dip\"/&gt; &lt;TableLayout android:layout_below=\"@id/FRppt01\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:stretchColumns=\"1\" android:layout_marginLeft=\"10dip\" android:layout_marginRight=\"10dip\" &gt; &lt;TableRow android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"5dip\"&gt; &lt;TextView android:id=\"@+id/textUserName\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textSize=\"12pt\" android:layout_weight=\"1\" android:layout_below=\"@id/FRppt01\" android:text=\"@string/userName\"/&gt;\" &lt;EditText android:id=\"@+id/editUserName\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"5dip\"&gt; &lt;TextView android:id=\"@+id/textPassword\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:textSize=\"12pt\" android:text=\"@string/passWord\"/&gt; &lt;EditText android:id=\"@+id/editPassword\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"5dip\"&gt; &lt;TextView android:id=\"@+id/textPhone\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:textSize=\"12pt\" android:text=\"@string/phone\"/&gt; &lt;EditText android:id=\"@+id/editPhone\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" /&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; &lt;TableLayout android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" &gt; &lt;TableRow&gt; &lt;Button android:id=\"@+id/btnBack\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"260dp\" android:layout_weight=\"1\" android:text=\"@string/Back\" /&gt; &lt;Button android:id=\"@+id/btnRegister\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"260dp\" android:layout_weight=\"1\" android:text=\"@string/Register\" /&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; &lt;/RelativeLayout&gt; 以上两段代码为布局文件代码。","categories":[{"name":"android","slug":"android","permalink":"https://scutccnl.github.io/categories/android/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"https://scutccnl.github.io/tags/tomcat/"},{"name":"servlet","slug":"servlet","permalink":"https://scutccnl.github.io/tags/servlet/"}]}]}